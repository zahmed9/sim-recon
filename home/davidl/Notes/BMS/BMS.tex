
\documentclass[12pt]{article}
\usepackage{epsfig}
\usepackage{anysize}
\usepackage{caption2}
\usepackage{listings}
\usepackage{color}

\definecolor{codebkgd}{rgb}{0.95,0.95,1.0}
\definecolor{cmdbkgd}{rgb}{0.95,1.0,0.95}

% Set reasonable margins
\marginsize{2cm}{2cm}{3cm}{2cm}
\setcaptionwidth{5.0in}

% These commands try to force figures to co-exist with text
% better than the default which tends to throw figures onto
% their own pages.
\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}

\author{D. Lawrence \\ Jefferson Lab}
\title{BMS: Build Management System}
\begin{document}

\maketitle

%\vspace{-6cm}
%\rightline{Hall-D-NOTE ??}
%\vspace{6cm}

%----------------------- Abstract -------------------------
\abstract{The BMS Build Management System is a set of GNU Makefiles
which simplify and standardize the building of source code distribruted
throughout a directory tree. Files with .c, .cc, or .F suffixes are
automatically compiled. Platform dependance is handled through
automatic inclusion of platform specific makefiles. The system 
also includes rules to automatically generate ROOT dictionaries
from any .h file which includes the {\it ClassDef} keyword.}

\newpage
\tableofcontents
\newpage

%----------------------- Introduction -------------------------
\section{Introduction}
The BMS is a set of GNU Makefiles which can be used to compile libraries
and link exectables from a collection of source files. In contrast
to a typical makefile, the BMS files contain no information about the
names of the files that they need to compile. Rather, they assume that all
source files in a directory should be compiled. It is believed that this can help 
lead to better maintenance of the source tree as files which should not be
compiled must not be kept among those that should.

A typcial users'
makefile will look like this:

\begin{lstlisting}[caption={Example Makefile},label=example
,frame=shadowbox,backgroundcolor=\color{codebkgd}]
PACKAGES = ROOT:DANA

include $(HALLD_HOME)/src/BMS/Makefile.bin
\end{lstlisting}

BMS was designed for use in the Hall-D source code environment. However,
it is general enough to be used in other applications. 

%----------------------- File Naming Conventions -------------------------
\section{File Naming Conventions}

\subsection{Makefiles}
The user makefiles (as shown in listing \ref{example}) can potentially
have any name. The recommendation however is to name them {\it Makefile}.
This name is one of a list that {\lstinline !gmake!} looks for
if one is not excplicitly passed to it on the command line.

The BMS files themselves are kept in the src/BMS directory and have
names of the form {\it Makefile.*} where the * represents one of:

\begin{itemize}
	\item{} the functionality provided by the makefile
	\item{} the ``OSNAME'' of the platform the makefile is being invoked on
	\item{} the package name of a package specific makefile
\end{itemize}

%----------------------- FORTRAN Files -------------------------
\subsection{FORTRAN Files}
BMS automatically invokes the fortran compiler for all files with
a ``.F'' suffix. Files with a ``.f'' suffix are ignored. This is
done for two reasons. The first is that the GNU F77 compiler
uses the suffix to determine whether or not to run the file
through the preprocessor. The ``.F'' files are while the ``.f''
files aren't. The preprocessor a replaces $\#$ directives such as
{\lstinline !#include, #define, and #if!} which would cause errors
in the g77 compiler proper.

The second reason is that PAW's built-in FORTRAN interpretor can
be used to process FORTRAN files which are never intended to be
compiled into and executable. By adopting the convention that
``.f'' files are for macros and ``.F'' files are for compiling,
the macros and source files can coexist in the same directory.

%----------------------- C/C++ Files -------------------------
\subsection{C/C++ Files}

C source files should end in ``.c'' while C++ source files should end
in ``.cc'', ``.cpp'', or ``.cxx''. The prefered suffix is ``.cc''.
Header files should end in ``.h''. In order to allow ROOT C++ macros
to coexist with source code, they should have the suffix ``.C''.

%----------------------- Binary Files -------------------------
\subsection{Binary Files}
The term ``Binary Files'' here means library files (e.g. libBAR.a),
executable files, and object files (e.g. foo.o). In general, the 
library files are kept in the directory $\$HALLD\_HOME/lib/\$OSNAME$
and the executables are kept in $\$HALLD\_HOME/bin/\$OSNAME$. The
output of the executables can be controlled through the $\$HALLD\_MY$
environment vaiable as described in section \ref{variables}. The object
files for libraries are kept inside the libray archives themselves.
For executables, the objects are kept in the directory $obj/\$OSNAME$
relative to the source directory. See section \ref{debug} for more
details and how the naming scheme for debug versions of the differs
from the non-debug versions.

%----------------------- BMS defined Rules and Custom Makefiles-------------------------
\section{BMS defined Rules and Custom Makefiles}
If you wish to include BMS in situations which require more customization
of the makefile, one can do so by adding a rule to their makefile
which uses the ``all'' rule as a depandancy. To avoid conflicts with
rules define by BMS, a somewhat complete is is given here:

\begin{itemize}
\item{all}
\item{mkdirs}
\item{clean}
\item{\%d : \%.cpp}
\item{\%d : \%.cxx}
\item{\%d : \%.cx}
\item{\%d : \%.c}
\item{\%d : \%.F}
\item{\%\_Dict.cc : \%.h}
\item{env}
\end{itemize}

%----------------------- make clean -------------------------
\subsection{make clean}
To clean out all depends files, objects, libraries, and executables
associated with a specific directory simply invoke:

\begin{lstlisting}[frame=single,backgroundcolor=\color{cmdbkgd}]
make clean
\end{lstlisting}

It is not a bad idea to do this every so often.

Note also that, as with other parts of BMS, doing a 
{\lstinline !make clean!}
will NOT recursively traverse directories. Only the files in
the current directory are considered. Multiple directories
can be "cleaned" with a single invocation of {\lstinline !make clean!}
by simply making a master makefile as described in section
\ref{multiple}.

%----------------------- make env -------------------------
\subsection{make env}
The $env$ rule is available for both the Makefile.lib and 
Makefile.bin make files. Invoking make with the ``env''
argument will print a list of variables (see section 
\ref{variables}) with their values. Some are user settable and
others are internal to BMS. This can be helpful when debugging
the make system

%----------------------- Dependancy Rules -------------------------
\subsection{Dependancy Rules}
\label{depends}
The purpose and power of a make system is to recompile only when
necessary. To accomplish this, the make system must be aware of
the dependancies of the source file. Specifically, the make system
should recompile a source file if either it or any header files
on which it depends are changed. To accomplish this, BMS makes use
of a feature of the GNU compilers to generate dependancy rules
by examining the source files themselves\footnote{See the $-M$
and $-MM$ options of gcc}. The dependancy rules are generated and
stored in files in the .depends directory relative to its source.
The depends files are given names with a $.d$ suffix.

Building these GNU Make compatible rules is specific to the GNU
compilers. As such, the BMS is hardwired to use the GNU compiler
to generate them {\bf even when using another compiler to actually
compile the code}! This limits use of the BMS to systems which have
the needed GNU compilers (g77, gcc, g++) installed. As these are
free and available for all platforms on which GNU make can run,
it should not be much of a real limitation.

%----------------------- ROOT Dictionaries -------------------------
\subsection{ROOT Dictionaries}
Some features of ROOT such as object I/O and the GUI classes can
only be accessed if the classes are defined to ROOT through a ROOT
dictionary. Dictionaries are made from the C++ header files using
the $rootcint$ program. To make it easier to add this functionality,
BMS defines a rule to run rootcint. It only applies the rule to
header files (ones ending in $.h$) that contain the string $ClassDef$.
In the Hall-D source code, a Makefile is placed in the 
$src/libraries/include$ directory specifically for this purpose.Since
the default name of $libinclude.a$ seems less than optimal, the
makefile specifies a different name ($libHDDICT.a$) with the following
Makefile:

\begin{lstlisting}[caption={Makefile from src/libraries/include}
,frame=shadowbox,backgroundcolor=\color{codebkgd}]
PACKAGES = ROOT

MODULE_NAME = HDDICT

include $(HALLD_HOME)/src/BMS/Makefile.lib
\end{lstlisting}
%$

Here, the $MODULE\_NAME$ variable is used to specify the alternate
name of the resulting library and the ROOT package is explicitly
included.

%----------------------- Modifying the behaviour of BMS -------------------------
\section{Modifying the behaviour of BMS}
The behaviour of BMS can be modified through the setting of
environment variables, or adding specialized makefiles to the
BMS directory. In general, the only files in the BMS directory
to have rules are $Makefile.common$ $Makefile.lib$ and $Makefile.bin$.
All others (except for very special cases) will only modify
variables (see section \ref{variables}). You may need to add a makefile
when porting BMS to a new platform or you may want to compile
using a different compiler. These situations are addressed in the
following sections.

%----------------------- Variables -------------------------
\subsection{Variables}
\label{variables}

\begin{itemize}
\item{OSNAME}: If not set, it is set to return value of $uname$ (e.g.
 $Linux$, $SunOS$, $Darwin$, ...)
\item{FC}: FORTRAN compiler. Default is $g77$
\item{CC}: C compiler. Default is $gcc$
\item{CXX}: C++ compiler. Default is $g++$
\item{DFC}: FORTRAN compiler used for generating dependancy rules.
  Default is g77 (see section \ref{depends})
\item{DCC}: C compiler used for generating dependancy rules.
  Default is gcc (see section \ref{depends})
\item{DCXX}: C++ compiler used for generating dependancy rules.
  Default is g++ (see section \ref{depends})
\item{HALLD\_HOME}: Points to the the directory which contains the
  $src$ directory. The libraries and executables will be placed
  in $\$HALLD\_HOME/bin/\$OSNAME$ and $\$HALLD\_HOME/lib/\$OSNAME$
\item{HALLD\_MY}: If this is set, executables will be placed in
  $\$HALLD\_MY/bin/\$OSNAME$, but libraries still come from
  $\$HALLD\_HOME/lib/\$OSNAME$
\item{FFLAGS}: Flags for FORTRAN compiler
\item{CFLAGS}: Flags for C compiler
\item{CXXFLAGS}: Flags for C++ compiler
\item{PACKAGES}: Colon separated list of packages for which to
  include the corresponding BMS makefiles.
\item{LIBS}: Libraries to include on the link command
\item{MODULE\_NAME}: Used as the base name for the output
  binary. Defaults to directory name for libraries and basename
  of "main" source file for executables.
\item{LD}: Linker. Defaults to $\$CXX$
\item{MISC\_LIBS}: Extra libraries added to the end of the link list.
\item{DEBUG}: If set, creates debug version of binaries (see
  section \ref{debug})
\item{LINK\_OBJS}: Extra link objects to add to the link command
\end{itemize}:

%----------------------- Platform Dependance -------------------------
\subsection{Platform Dependance}
Platform dependance is handled by including a platform specific 
makefile which is part of BMS. This done automatically with the OSNAME
variable (see section \ref{variables}). The {\lstinline !-include!}
command is used rather than {\lstinline !include!} (without the
``-'') because it will not give an error if the file does not exist.
This means that new platforms at least have a chance to compile.
Every effort should be made to develop the software in
platform-independant ways so the content of the platform dependant
Makefiles is minimized.
In fact, at the time of this writing, there is no
{\lstinline !Makefile.Linux!} because there are no special requirements
for the Linux platform. The best example of an existing BMS makefile
which incorporates platform dependant settings is the Mac OS X
file {\lstinline !Makefile.Darwin!} (so named because {\lstinline !uname!}
returns ``Darwin'')

\begin{lstlisting}[caption={Makefile.Darwin}, label={darwin}
,frame=shadowbox,backgroundcolor=\color{codebkgd}]
\# This defines flags which can implement (or not) features
\# in a way compatible with this OS

OSXFLAGS = -DBASENAME\_IN\_LIBGEN -DXDR\_LONGLONG\_MISSING -Wno-long-double

CFLAGS += \$(OSXFLAGS)
CXXFLAGS += \$(OSXFLAGS)
\end{lstlisting}

The important thing to note here is that the additional settings
for the $CFLAGS$ and $CXXFLAGS$ variables are {\bf appended} to
the variables. This will insure settings placed there by the
generic system are not overwritten.

The other point to notice in listing \ref{darwin} is that 
``BASENAME\_IN\_LIBGEN'' and ``XDR\_LONGLONG\_MISSING''
are features. These are used to control sections of compilation
in the code by using preprocessor directives like:
{\lstinline !#ifdef XDR_LONGLONG_MISSING!}. You generally want to
avoid using the platform itself by doing something like this:
{\lstinline !#ifdef Darwin!}. Compiling on features rather than
platforms allows one to turn on/off sections related to single features.
Using the platform as the conditional couple all conditionals for
a single platform together.

%----------------------- Compilers -------------------------
\subsection{Compilers}
By default, the GNU compilers (g77, gcc, and g++) are used. The
compilers can be changed by setting the FC, CC, and CXX variables
(see section \ref{variables}). Note that the GNU versions must still
be present though since they are used to produced the dependancy 
rules as described in section \ref{depends}.

To override one or all of the compilers, one can set the environment
variable of the appropriate name before invoking $gmake$.

It may be desirable to always use a particular compiler on a 
certain platform. For example, the solaris compiler on SunOS
machines. In this case, the FC, CC, and CXX variables should be
set in the platform specific makefile {\lstinline !Makefile.SunOS!}.

%----------------------- Building across multiple directories -------------------------
\section{Building across multiple directories}
\label{multiple}
BMS was designed for a software heirarchy in which directories contain
more or less independant packages. When executables are made,
BMS assumes the libraries it needs to link against are up to date
rather than checking
if they need to be rebuilt. It is done this way since it can
often be the case that one links against libraries stored in a
group area where one lacks either the source code or the
neccessary privileges to rebuild them.

To use BMS across multiple directories, a ``master'' makefile
should be created which invokes {\lstinline !make!} in the
appropriate subdirectories. For example, the makefile that is
in the {\lstinline !src/libraries!} directory looks like this:

\begin{lstlisting}[caption={Makefile from src/libraries},label=mastermakefile
,frame=shadowbox,backgroundcolor=\color{codebkgd}]
.PHONY: all


all:
	make -C include
	make -C BCAL
	make -C CDC
	make -C CHERENKOV
	make -C DANA
	make -C FCAL
	make -C FDC
	make -C HDDM
	make -C TAGGER
	make -C TOF
	make -C TRIGGER
	make -C UPV
	make -C TRACKING

clean:
	make -C include clean
	make -C BCAL clean
	make -C CDC clean
	make -C CHERENKOV clean
	make -C DANA clean
	make -C FCAL clean
	make -C FDC clean
	make -C HDDM clean
	make -C TAGGER clean
	make -C TOF clean
	make -C TRIGGER clean
	make -C UPV clean
	make -C TRACKING clean
\end{lstlisting}

This just runs {\lstinline !make!} (or {\lstinline !make clean!})
in each of the specified directories. BMS does NOT recursively
traverse directory structures. Having BMS recursively search
subdirectories would complicate the system for little gain. Writing
makefiles such as the one in listing \ref{mastermakefile} are
trivial enough and leave a level of control with the user.

This same mechanism can be employed for directory trees in which
more than one level cotain source code. For example: One has 
source code in a directory called ``foo'', but there is also
a subdirectory of foo named ``foo/bar'' which contains source
code. One could make a master makefile called {\lstinline !Makefile!}
and a BMS specific one called something like {\lstinline !Makefile.bms!}.
The two would look like this:

\begin{lstlisting}[caption={Makefile}
,frame=shadowbox,backgroundcolor=\color{codebkgd}]
all:
	make -C bar
	make -f Makefile.bms

clean:
	make -C bar clean
	make -f Makefile.bms clean
\end{lstlisting}

\begin{lstlisting}[caption={Makefile.bms}
,frame=shadowbox,backgroundcolor=\color{codebkgd}]
PACKAGES = ROOT:DANA

include $(HALLD_HOME)/src/BMS/Makefile.bin
\end{lstlisting}

%----------------------- Building Debugging Versions -------------------------
\section{Building Debugging Versions}
\label{debug}
By default, files are compiled without debugging symbols and with
level 2 optimization \footnote{Optimization is not used
for FORTRAN files since the large hddsGeant3.F file in the Hall-D source
code fails to compile with optimization on.} ($-O2$ flag).
However, if the variable DEBUG is set,
then instead of the default optimization, the $-g$ and $-pg$ 
flags are set. The $-g$ flag adds debugging symbols while the
$-pg$ flag turns on profiling\footnote{see {\it gprof}} and
includes the proper compiler libraries \footnote{The $-g$ flag
seems widely used while the $-pg$ flag may be GNU specific.}.

The DEBUG variable can be set either through the environment,
or by passing it explicitly on the command line:

\begin{lstlisting}[frame=single,backgroundcolor=\color{cmdbkgd}]
make DEBUG=yes
\end{lstlisting}

The value of DEBUG is ignored. It is only checked if it is set. As
such, compiling with {\lstinline !DEBUG=no!} would produce the same
result as the above example.

The debugging versions of binaries are given suffixes of {\b \_d}
to distinguish them from their non-debug counter parts and so that
they may share directories with them. For example, a library named
$libFOO.a$ will have a debug version named $libFOO\_d.a$. An executable
named $BAR$ will have a debug version named $BAR\_d$.

When making a debugging version of na executable, it is assumed that
the needed debugging version of the libraries have been made.
This is the same behaviour as for non-debug versions. The point
being that one cannot link debug-objects in an executables
directory with non-debug libraries.

It may be worth noting that the objects created from the source 
files follow a slightly different naming scheme. Objects created
for libraries are stored in the library archive itself. These objects
are given the same names as those in the non-debug version. For
example, a file named $recon.cc$ in the directory FOO will be stored
as an object named $recon.o$ in both $libFOO.a$ and $libFOO\_d.a$.
By contrast, objects in directories which contain source which
is to be linked into executables are stored as separate files in
the $obj$ directory. For these, the object files each carry the 
$\_d$ suffix. For example, a file named $myprog.cc$ would be
stored as $obj/Linux/myprog\_d.o$ (on a Linux system). This is a
detail that one does not generally need to know since this is
all taken car of by BMS.


%----------------------- Questions -------------------------
\section{Questions}
Please refer any questions to David Lawrence at $davidl@jlab.org$.

\end{document}


