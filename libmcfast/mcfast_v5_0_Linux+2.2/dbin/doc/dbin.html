<title>DBin User's Guide and Reference</title>
<body>

<!-=======================================================================>
<center>
<h1>DBin (<i>`dee-bee-in'</i>) DataBase INput System <br> User's Guide and Reference</h1>
<a href="http://www-hep.llnl.gov/wenaus/whoami.html">Torre Wenaus</a>,
<a href="http://www.llnl.gov/">LLNL</a>
<h3>Under (perpetual) construction, but hopefully useful</h3>
</center>
<hr>
<i>The basics:</i>
<a href="#intro">[Intro]</a> -
<a href="#operation">[Operation]</a> -
<a href="#lang">[f77 and C/C++]</a> -
<a href="#files">[Generated files]</a> -
<a href="#data">[Data types]</a> -
<a href="#syntax">[Syntax]</a>
<br>
<i>Using DBin:</i>
<a href="#db">[Creating a db]</a> -
<a href="#datst">[Data Struct Def'n]</a> -
<a href="#cmd">[Command Def'n]</a> -
<a href="#xdr">[XDR I/O]</a> - 
<a href="#running">[Running DBin]</a>
<br>
<i>Reference:</i>
<a href="#internals">[Internals of DBin]</a> -
<a href="#ref"><b>[Directives Reference]</b></a>
<br>
<i>Applications:</i>
<a href="#mcfast">[MCFast (Fermilab)]</a> -
<a href="#bbsim">[BBSIM (BaBar)]</a>
<br>
<i>Examples:</i>
<a href="#ex-db">[Database]</a> -
<a href="#ex-dst">[Data structure definition]</a> -
<a href="#ex-cmd">[Command definition]</a>
<br>
<i>History:</i>
<a href="#bbsimDBin">[6/95 status (BaBar version)]</a> -
<a href="#changes">[Changes since]</a>
<hr>

<!------------------------------------------------------------------------>
<a name="intro"></a>
<h2><hr>Introduction to DBin<hr></h2>

DBin is a tool used to define and build databases and data structures used in
Fortran, C/C++, or mixed language programs in a language independent
way. It generates automatically all the code necessary to
initialize, read, write, and access the data structures from either
language, with a user-written ASCII DBin file defining the data structures
and (for the database application) serving as the data repository.
<p>
XDR-based I/O is supported: DBin automatically generates the filters
and associated code necessary for XDR I/O on databases and data
structures.
<p>
In a single-language program environment DBin is useful to maintain
databases and data structures in an organized, easily transportable,
self-documented way,
with much tedious coding of I/O routines, include files, XDR
filters, and so on eliminated by DBin's automatic code generation.
<p>
It is, however, in multi-language environments -- programs which
either support coding in multiple languages or are migrating between
languages (most commonly, from Fortran to C++) -- that DBin's utility
is greatest. Without DBin such an environment can present a
maintenance nightmare requiring redundant coding of Fortran and C/C++
I/O codes, careful maintenance of consistency between the Fortran and
C/C++ data structures coded into the header files, multiple coding
changes in multiple languages when a data structure or database object
changes, etc. With DBin, the coding overhead remains the same as for a
single language: <i>zero</i>.  DBin makes a multiple language
environment much more practical and maintainable.
<p>
DBin maps the Fortran and C databases/data structures onto the
same memory, so that inter-language data sharing concerns are
eliminated and data can be accessed from either language in a
transparent way.


<!------------------------------------------------------------------------>
<a name="operation"></a>
<h2><hr>DBin operation<hr></h2>

DBin works with an ASCII definition file written by the user that
provides
<ul>
  <li> Definitions of the database objects or data structures
  <li> A database/data structure name and version (to support
       multiple databases or data structure definition files
       in an application, and to support version control and
       verification)
  <li> A repository for the data itself, in the case of the
       database application
</ul>

The DBin file is processed by the DBin program, the output of which
is a set of source and include files for Fortran and C that provide
everything needed to work with the database and/or data structures
in the two languages and C++.
<p>
The DBin program is a lex program that runs on any Unix platform.
Auxiliary material for DBin (mostly parsers) is in Fortran and C.
<p>
The databases and data structures generated by DBin are implemented
using conventional C structures on the C side and VMS-style Fortran
structures on the Fortran side. A Fortran 90 option is under
consideration. If only a Fortran 90 compiler is available, a
VMS to Fortran 90 structure syntax converter is available from the
author and can be run on DBin's output to turn it into Fortran 90.


<!------------------------------------------------------------------------>
<a name="lang"></a>
<h2><hr>Use of DBin in Fortran, C and C++ programs<hr></h2>

The database objects and data structures defined using DBin are
implemented as C structures and VMS Fortran structures in the
respective languages. The representation in memory of these
structures, including character strings (implemented in C as
char arrays) and nested structures, is
identical in the two languages, permitting the C and Fortran
structures to be mapped to the same memory for transparent
dual-language access to the same data space.

<!------------------------------------------------------------------------>
<a name="files"></a>
<h2><hr>Files generated by DBin<hr></h2>

The following files are generated by DBin in processing a definition
file given the name <code>foo</code> (using the <code>database</code>
directive; see the reference section).


<h3>Fortran interface files:</h3>
<dl>
  <dt> <code>foo_read.F</code>
  <dd> Database application only. Reads the database file treating it
       as a data source, and loads internal data structures defined
       in the .inc file. The database file read need not be
       complete; it can be only a subset, containing values different
       from the defaults (see next routine). Or, no database file
       need be read at all at runtime if the default values are
       desired.
  <dt> <code>foo_init.F</code>
  <dd> Database application only. Sets default values for all
       database parameters. Values used are those present in the
       file on which DBin was run to generate the code. Default
       values can be overridden at run time by the optional read
       routine (see previous routine). 
  <dt> <code>foo_db.inc</code>
  <dd> The header file containing the data structures DBin has
       built to represent the database or data structures. Often,
       the <code>incname</code> directive is used to direct
       header material to one or more files with user-defined
       names rather than the default behaviour of everything being
       written to this file.
</dl>


<h3>C interface files:</h3>
<dl>
  <dt> <code>fooRead.c</code>
  <dd> C version of foo_read.F; see above.
  <dt> <code>fooInit.c</code>
  <dd> C version of foo_init.F; see above.
  <dt> <code>foo_db.h</code>
  <dd> C version of foo_db.inc; see above. Note that the data space
       that the structure definitions in the two languages map to
       is the same space in memory.
</dl>
       
<h3>XDR interface files:</h3>
<dl>
  <dt> <code>fooXDR.c</code>
  <dd> The XDR filter code for all defined data structures. One
       filter routine for each structure.
  <dt> <code>fooXDRall.c</code>
  <dd> The controller routine that calls the IO routines for
       all the defined structures. If not all structures should
       be written to XDR output, this file should be modified
       (appropriate structure calls commented out). 
  <dt> <code>fooXDRinc.h</code>
  <dd> Needed function declarations.
  <dt> <code>fooXDRmgr.c</code>
  <dd> Manages the IO for each structure. Calls each structure's
       filter routine for each instantiation of the structure.
       One function per structure. These functions are called
       in the fooXDRall.c routine.
</dl>

<h3>GUI interface file:</h3>
<dl>
  <dt> <code>fooGUI.h</code>
  <dd> The menu definitions for Kai Mantsch's <b>geomedit</b>
       Motif-based DBin geometry file editor.
</dl>

<!------------------------------------------------------------------------>
<a name="data"></a>
<h2><hr>Structures, data types and directives<hr></h2>

DBin organizes data into objects analogous to C structures (the
objects are implemented as C structures in the generated code).
There are two basic types of object defined by DBin. One is
the <b>structure</b>, which is an object with only a single
instantiation. This object is used only in the database application.
It is used to define parameters for which there is only a single
instance. (Structures are used extensively in bbsim geometry
definitions, and not at all -- at present -- in MCFast). In a
structure, the data values are set within the body of the
structure definition.

<p>
The other object type is the <b>template</b>, which can be
multiply instantiated (implemented as an array of C structures
in the code). Data values cannot be declared within the template
definition, because multiple instantiations can exist. Rather,
instantiations are created and their data values set using the
<code>make</code> directive.
<p>
In the data structure definition application, the <code>make</code>
directive is not used, because no explicit instantiations
are declared in this case. 

<p> Within structures and templates, the standard data types are
available: integer, real, double precision, and character string, with
keywords <b>int, real, double, char</b>. Arrays are permitted;
singly dimensioned only, for the database application. Arrays of
higher dimension are permitted in data structure definitions.
Nested templates are permitted in data structure definitions. They
are not permitted in databases because of the complexity it would
introduce to declaring the data values.


<!------------------------------------------------------------------------>
<a name="syntax"></a>
<h2><hr>Syntax rules<hr></h2>

<ul>
  <li> Basic components of a line are
       <pre>
       keyword name(dimension) [names and values]
       </pre>
       If a declaration has an associated dimension, it <i>always</i>
       appears as a dimension on the second token.
  <li> The column in which a line begins is not significant
  <li> Indenting the contents of a template or structure definition
       is encouraged.
  <li> The line continuation character is the slash, /
  <li> Character strings must appear in double quotes, ie. "string", and
       can contain embedded blanks
  <li> Instantiations of a template <b>must</b> immediately follow
       the template definition, without other intervening template
       (or structure) definitions. That is, template usage in a database
       file has the overall structure
       <pre>
       template one
         int i
       end template
       make one 4    ! OK
       make one 5    ! OK
       ...
       template two
         real r
       end template
       make two 6.   ! OK
       make two 27.4 ! OK
       make one 7    ! illegal line. Intervening template.
       </pre>
  <li> Structures and templates can be declared in any order.
  <li> NB. VERY long line lengths (summed over all continuation lines)
       can exceed internal string lengths; current limit is 500
       characters.
  <li> An <code>include</code> directive is available to include
       other files.
  <li> The <code>end</code> directive is a required final termination of the
       full definition file.
</ul>

<!------------------------------------------------------------------------>
<a name="db"></a>
<h2><hr>Creating a database<hr></h2>

For the database application, a DBin file simultaneously serves as
data structure definition and data repository. DBin structures
contain embedded data. DBin template definitions are followed by
explicit instantiations via the <code>make</code> directive.
<p>
By convention, DBin database files have file type .db .
<p>
The basic structure of a database file, with examples of both
structures and templates, is as follows.
<pre>
------------------------------------------------------------------------
database mydb  0100   ! name and version number

incname pars          ! specify pars.h, pars.inc as destination
                      ! for header material

structure pars
  char name "An example"
  real rad 320.
  real zlen 400.
  int nphi 36
  real origin(3) 10. 20. 30. 
end structure

incname plane        ! new destination: plane.h, plane.inc

template plane
  char name
  int index
  real normal(3)
  real point(3)
end template

make plane "xy" 1 0. 0. 1. 0. 0. 0.
make plane "yz" 2 1. 0. 0. 0. 0. 0.

include otherstuff.db   ! include material in another file

end
------------------------------------------------------------------------
</pre>

<!------------------------------------------------------------------------>
<a name="datst"></a>
<h2><hr>Using DBin to define program data structures<hr></h2>

When DBin is used to define data structures, only template
definitions appear in the DBin file. No data appears in the file;
hence no instantiations (<code>make</code>) or DBin structures
(<code>structure</code>). The declaration <code>mode internal</code>
<i>must appear as the first line in the DBin file</i> to indicate
the application mode is generation of program-internal data
structures rather than a database (the default usage mode). 
<p>
By convention, DBin data structure definition files have file type .dst .
<p>
Because DBin does not have the job of handling actual data in
this application, DBin's rules on allowed declarations are more
liberal. The following are permitted in data structure definitions,
but not in the database application:
<ul>
  <li> Declaration of an array size using a constant declared with
       the <code>dimension</code> directive. eg.
       <pre>
       dimension nmxsiz
       template foo
         real array(nmxsiz)
         ...
       end template
       </pre>
  <li> Declaration of multi-dimensional arrays is allowed.
  <li> Declaration of nested templates is allowed via the
       <code>nest</code> directive. eg.
       <pre>
       template inner
         int i
       end template
       template outer
         real r
         nest inner(5)
       end template
       </pre>
</ul>
An example of a simple data definition file is as follows.

<pre>
------------------------------------------------------------------------
mode internal   ! usage mode = data structure def. Must be 1st line.
database mcfdat 0100
!
!  Definition of data structures used internal to MCFast
!

!******************** hit_trk ********************

incname trk_channel_struct   ! include file for structure declaration
template trk_channel
        int devtype   !Type of device
        int devnum    !Device # of this type
        int devlayer  !Layer #
        int devwid(3) !Info within layer
end template

incname hit_trk_struct   ! include file for structure declaration
provide trk_channel_struct     ! provide the channel declaration
template hit_trk
        int hep                !Position of track in /HEPEVT/ list
        int trace              !Position of hit in trace list
        nest trk_channel chan  !Device info
        double pos(3)          !Position of wire
        double dircos(3)       !Dir. cosines
end template

incname hit_trk  ! instantiations go to a separate include file
provide hit_trk_struct        ! provide the structure declaration
dimension hit_trk_max 10000    ! define the dimension parameter
record hit_trk(hit_trk_max)   ! create an array: hit_trk

incname another_hit_trk       ! create another include file
provide hit_trk_struct        ! provide the structure declaration
dimension hit2_trk_max 10000     ! define the dimension parameter
record hit_trk(hit2_trk_max) hit2_trk ! create an array, hit2_trk


end
------------------------------------------------------------------------

</pre>

<!------------------------------------------------------------------------>
<a name="xdr"></a>
<h2><hr>XDR-based I/O using FNAL's MCFIO package<hr></h2>


<!-------------------->
<h3>XDR filter routine</h3>

<!-------------------->
<h3>XDR I/O management routine</h3>


See above discussion on generated files.

<!------------------------------------------------------------------------>
<a name="running"></a>
<h2><hr>Running DBin<hr></h2>

To run DBin:
<pre>
  dbin dbfile.db [-help] [-list]         # database application
or
  dbin dstfile.dst [-help] [-list]       # data structure def'n

-help:   list available command line options
-list:   debug listing as DBin executes
</pre>


<!------------------------------------------------------------------------>
<a name="apps"></a>
<h2><hr>Current DBin applications<hr></h2>



<!------------------------------------------------------------------------>
<a name="internals"></a>
<h2><hr>The internals of DBin<hr></h2>

<h3> Data storage </h3>

Data is stored in C as C structures, with strings represented by
80 character char arrays. In Fortran, data is represented as
VMS-style Fortran structures, with strings as CHARACTER*80.
Happily and probably not accidentally,
the representation of the data in memory is identical
in the two languages (at least on the platforms tested). This
permits the data spaces of the two languages to be coincident,
and this is implemented by mapping the C data space to a
Fortran common block.

<h3>The DBin program</h3>
DBin is a lex program, <code>dbin.lex</code>.
Lex is a standard unix utility used for
developing parsers. Auxiliary code includes parser code for
database reading in Fortran and C, <code> dbinf.F and dbinc.c</code>.




<p>
<!-=======================================================================>
<a name="ref"></a>
<hr><center><h1>Directives Reference</h1></center><hr>

<i>General:</i>
<a href="#c-mode">[mode]</a>
<a href="#c-database">[database]</a>
<a href="#c-include">[include]</a>
<a href="#c-incname">[incname]</a>
<a href="#c-provide">[provide]</a>
<a href="#c-end">[end]</a>
<br>
<i>Data Types:</i>
<a href="#c-integer">[integer]</a>
<a href="#c-real">[real]</a>
<a href="#c-double">[double]</a>
<a href="#c-char">[char]</a>
<a href="#c-material">[material]</a>
<a href="#c-dimension">[dimension]</a>
<a href="#c-index">[index]</a>
<br>
<i>Data Structures:</i>
<a href="#c-structure">[structure]</a>
<a href="#c-template">[template]</a>
<a href="#c-record">[record]</a>
<a href="#c-child">[child]</a>
<a href="#c-nest">[nest]</a>
<a href="#c-parent">[parent]</a>
<a href="#c-make">[make]</a>
<a href="#c-define">[define]</a>
<br>
<i>FFREAD file inclusion:</i>
<a href="#c-ffread">[ffread]</a>
<a href="#c-ffend">[ffend]</a>
<a href="#c-any">[any]</a>
<br>
<i>General file inclusion:</i>
<a href="#c-file">[file]</a>
<a href="#c-fileend">[fileend]</a>
<br>
<i>Command mode:</i>
<a href="#c-command">[command]</a>
<a href="#c-call">[call]</a>

<!------------------------------------------------------------------------>
<h2><hr>General directives<hr></h2>
<!-------------------->
<a name="c-mode"></a>
<h3><hr>mode</h3>
<code>
mode internal
</code><p>
The <tt>mode</tt> directive is used to change the mode of operation of the
program from the default <b>database</b> mode to something else.
One other mode is presently defined: <b>internal</b> mode, in which
DBin is used to define a program's internal data structures. If
present, it must appear as the <i>first line</i> of the DBin file as above.

<!-------------------->
<a name="c-database"></a>
<h3><hr>database</h3>
<code>
database <i>db_name</i> <i>version</i>
</code><p>
The <tt>database</tt> directive names the database; it sets the name used in
filenames generated by DBin. It also defines a version number, used
to ensure that DBin-generated code is used only with compatible database
files (ie. with matching version number).
<p>
The <tt>database</tt> directive <b>must appear</b>, and
should be the <b>first directive</b> in the DBin file
(unless preceded by the <tt>mode</tt> directive).
<p><code>
database bbgeom 0100
</code>

<!-------------------->
<a name="c-include"></a>
<h3><hr>include</h3>
<code>
include <i>file_name</i>
</code><p>
The <tt>include</tt> directive permits the in-line inclusion of DBin statements
from another file (just like the <tt>cpp</tt> <tt>#include</tt> command). The
file name will be looked for in the same directory as the parent DBin file,
unless the name includes a relative or absolute path name.
<p><code>
include db/subsystem.db
</code>

<!-------------------->
<a name="c-incname"></a>
<h3><hr>incname</h3>
<code>
incname <i>file_name_root</i>
</code><p>
The <tt>incname</tt> directive reroutes include file code generated by DBin to
a file of the specified name, rather than to DBin's master include file (the
master include file instead uses <tt>#include</tt> to include these user-specified
files). Using this directive the user has complete control over the partitioning
of include file code among files.
<p>
The specified file name should <b>not</b> contain an extension. Appropriate
extensions (<tt>.inc</tt>,<tt>.h</tt>) will be added by DBin for the Fortran
and C/C++ versions of the file.
<p><pre>
incname muon  ! header code directed to muon.inc, muon.h
[<i>...DBin statements...</i>]
incname ecal  ! header code directed to ecal.inc, ecal.h
</pre>

<!-------------------->
<a name="c-provide"></a>
<h3><hr>provide</h3>
<code>provide <i>include_file_root</i>
</code><p>
The <code>provide</code> directive inserts an <code>#include</code>
statement for the named include file into the current header file.
The file type should not be given. File types of <code>.inc</code>
and <code>.h</code> will be added for the Fortran and C includes
respectively.
<p><pre>
provide muon ! inserts '#include "muon.[inc,h]"' into Fortran,C header
</pre>

<!-------------------->
<a name="c-end"></a>
<h3><hr>end</h3>
<code>
end
</code><p>
The <code>end</code> statement signals the end of the dbin file.
It must be present.
Note that included files should not contain an end statement.
<p><code>
</code>

<!------------------------------------------------------------------------>
<h2><hr>Data Types<hr></h2>

All data types can be dimensioned, eg. <code>real array(5)</code>.
In databases, only one dimensional arrays with an explicit numeric
dimension are allowed. In structure definitions, multi-dimensional
arrays are allowed, comma delineated. Also, dimensions can be
given in terms of constants declared (previously) with the
<code>dimension</code> directive.

<p>
In structure definitions (ie. only in databases), a type declaration
is followed by the data for the parameter. A single value if undimensioned,
all N values if dimensioned. In all other contexts (ie. templates,
in either database or data structure def'n applications), the
type declaration does not include data.

<p>
Arrayed types can be followed by the keyword <code>variable</code>
to indicate that it is a variable size array; that is, its declared
size is an upper bound on the number of elements actually used.
The previous element in the template declaration should be an
integer, and is interpreted as the number of elements actually used.
eg.
<pre>
   real hits(100) variable
</pre>

<!-------------------->
<a name="c-integer"></a>
<h3><hr>integer</h3>
<code> integer <i>name</i>[<i>(dimension)</i>] [variable]
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-real"></a>
<h3><hr>real</h3>
<code> real <i>name</i>[<i>(dimension)</i>] [variable]
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-double"></a>
<h3><hr>double</h3>
<code> double <i>name</i>[<i>(dimension)</i>] [variable]
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-char"></a>
<h3><hr>char</h3>
<code> char <i>name</i>[<i>(dimension)</i>] [variable]
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-material"></a>
<h3><hr>material</h3>
<code> material <i>name</i>[<i>(dimension)</i>] [variable]
</code><p>
Identical to <code>char</code>. Flags the string as of a special
type, one specifying the name of a material. Provokes special
treatment eg. in GUI menu code.
<p><code>
</code>

<!-------------------->
<a name="c-dimension"></a>
<h3><hr>dimension</h3>
<code> dimension <i>name</i> <i>value</i>
</code><p>
Acts like a <code>PARAMETER</code> statement in Fortran or <code>static const</code>
statement in C (these are how it is implemented). 
<p><pre>
dimension maxsz 30
</pre>

<!-------------------->
<a name="c-index"></a>
<h3><hr>index</h3>
<code>
index <i>prefix</i> <i>name1</i> <i>name2</i> <i>name3</i> ...
</code><p>
Sets up an array of index mnemonics useful for referencing elements
of arrays with mnemonics. Handles the 0/1 array start discrepancy
between Fortran and C such that the mnemonic in the given language
refers to the same element. The example below defines
<code>ix_x, ix_y, ix_z, ix_px, ...</code> to be mnemonics pointing to
the 1st (0th), 2nd (1st), etc. element in an array in Fortran (C).
<p><pre>
index ix x y z px py pz e
</pre>

<!------------------------------------------------------------------------>
<h2><hr>Data Structures<hr></h2>

<!-------------------->
<a name="c-structure"></a>
<h3><hr>structure</h3>
<code>structure <i>name</i>
</code><p>
Start a structure declaration. Structure is terminated by
<code>end structure</code>.
<p><code>
</code>

<!-------------------->
<a name="c-template"></a>
<h3><hr>template</h3>
<code>template <i>name</i>
</code><p>
Start a template declaration. Template is terminated by
<code>end template</code>.
<p><code>
</code>

<!-------------------->
<a name="c-record"></a>
<h3><hr>record</h3>
<code>record <i>template_name</i>[<i>(dimension)</i>] [alternate_name]
</code><p>
<b>Data structure definition mode only</b>. Create an instantiation
of a declared template, ie. create an object in memory. Dimension
is optional. By default (no third parameter), name of the created
structure as the template name. The third parameter is used to
specify an alternate name.
<p><pre>
record fourvec(3) products  ! == record /fourvec_s/ products(3) in Fortran
</pre>

<!-------------------->
<a name="c-child"></a>
<h3><hr>child</h3>
<code>child <i>template_name</i>
</code><p>
<b>Databases only.</b>
Appears in a template declaration. Declares that the object has a
child array of the stated type at the current point in the object.
The preceding element should be an integer (if not another child)
which is interpreted as the number of child elements in use.

<p><code>
</code>

<!-------------------->
<a name="c-nest"></a>
<h3><hr>nest</h3>
<code>
nest <i>template_name</i>[<i>dimension</i>] [variable]
</code><p>
<b>Data structure definitions only.</b>
Equivalent to child. In the context of a data structure definition,
the effect of the nest directive is to insert a nested structure
in the declared structure. 
<p><code>
</code>

<!-------------------->
<a name="c-parent"></a>
<h3><hr>parent</h3>
<code> parent <i>parent_template_name</i>
</code><p>
<b>Database definitions only.</b> Appears in template definitions.
If the template is a child of another template, the <code>parent</code>
directive should be inserted in the child template definition (anywhere)
to flag that the template has the named parent.
<p><code>
</code>

<!-------------------->
<a name="c-make"></a>
<h3><hr>make</h3>
<code> make <i>template_name</i> <i>template_parameters</i>
</code><p>
Create an instantiation of a template. Template instantiations
<b>must</b> follow the template definition with no intervening
template or structure definitions. That is, template instantiations
must be grouped together and appear right after the template
definition.
<p><pre>
template point
  real x
  real y
  real z
end template
make point 1. 2. 3. 
</pre>

<!-------------------->
<a name="c-define"></a>
<h3><hr>define</h3>
<code>
</code><p>
Not presently used. Reserved to re-implement the old style <code>make</code>
command that included a name for each instantiation.
<p><code>
</code>

<!------------------------------------------------------------------------>
<h2><hr>FFREAD file inclusion<hr></h2>

<!-------------------->
<a name="c-ffread"></a>
<h3><hr>ffread</h3>
<code>
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-ffend"></a>
<h3><hr>ffend</h3>
<code>
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-any"></a>
<h3><hr>any</h3>
<code>
</code><p>
<p><code>
</code>

<!------------------------------------------------------------------------>
<h2><hr>General file inclusion<hr></h3>

<!-------------------->
<a name="c-file"></a>
<h3><hr>file</h3>
<code>
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-fileend"></a>
<h3><hr>fileend</h3>
<code>
</code><p>
<p><code>
</code>

<!------------------------------------------------------------------------>
<h2><hr>Command mode<hr></h2>

<!-------------------->
<a name="c-command"></a>
<h3><hr>command</h3>
<code>
</code><p>
<p><code>
</code>

<!-------------------->
<a name="c-call"></a>
<h3><hr>call</h3>
<code>
</code><p>
<p><code>
</code>


<!-=======================================================================>
<a name="ex"></a>
<hr><center><h1>Applications</h1></center><hr>

<!------------------------------------------------------------------------>
<a name="mcfast"></a>
<h2><hr>MCFast, Fermilab's fast simulation package<hr></h2>
See also the <a href="http://www-pat.fnal.gov/personal/tw/mcfast-ext.html">MCFast extensions
documentation</a>.


<!------------------------------------------------------------------------>
<a name="bbsim"></a>
<h2><hr>bbsim, the Geant simulation of BaBar<hr></h2>
See also the <a
href="http://www.slac.stanford.edu/BFROOT/src/bbsim/bbsim/doc/bbsim.html">bbsim User's Guide</a>.

<p>
<!-=======================================================================>
<a name="ex"></a>
<hr><center><h1>Examples</h1></center><hr>

<!------------------------------------------------------------------------>
<a name="ex-db"></a>
<h2><hr>Database example<hr></h2>

See MCFast distribution, src/dbin/template.db and included template
files.

<!------------------------------------------------------------------------>
<a name="ex-dst"></a>
<h2><hr>Data structure definition example<hr></h2>

See MCFast distribution, src/dst/mcfdat.dst

<!------------------------------------------------------------------------>
<a name="ex-cmd"></a>
<h2><hr>Command definition example<hr></h2>


<!-=======================================================================>
<a name="changes"></a>
<hr><center><h1>History</h1></center><hr>


To add:
<pre>
'index' assigns 1,2,3,4... (C: 0,1,2,3...) to the symbols. Token following 'index'
! is a prefix to attach to each subsequent symbol, eg
       ! 'index mu px py pz' defines mu_px=1, mu_py=2, mu_pz=3
</pre>

</body>
