Suggested guidelines:
1) Add new notes at the top of the file, just below this guidelines section.
2) Use this file to document changes which
       a) require changes to  several files to implement
    or b) require more documentation which can be sensibly added
          with a one line cvs comment.
    or c) are major changes
3) There is no need to document here things such as "improved comments".

-------------------------------------------------------------------------------
February 22, 2000 Rob Kutschke

In klm_fit_ftk_one_pass.c I released the constraint that the
seed track must be specified at the z of the first node.  The code
now does a vacuum move to the first node.  This adds no functionality
to mcfast but introduces negligible overhead; it does add useful
functionality to the standalone fitter.  Users can now specify a seed 
anywhere in the general neighbourhood fo the first node.

-------------------------------------------------------------------------------
February 7, 2000 Rob Kutschke

1) I have done a partial fix to the bug reported in mcfast-dev in the
   note dated:    Sun Feb 06 2000 - 12:40:08 CST

   The problem has been corrected for siz_rect devices.  This means that
   all devices needed for the BTeV proposal are now working correctly.

   The problem also exists in all other devices and I have put these
   on my todo list.  At the moment there is no projection for when they
   will be fixed.

   The method Medium::reactTo contains the line:
   MCFBool status = detectorResponse( particle, oHitActiveArea );

   where oHitActiveArea is ultimately filled by the generateResponse
   method of a the various devices, such as:
   XYPixelPlane::generateResponse

   The way that reactTo uses oHitActiveArea suggests that the variable
   is misnamed; it should be true if the particle hits material,
   regardless of whether or not that part of the material is active and 
   regardless of whether or not a hit is created.

   In the various detector specific methods, such as 
   XYPixelPlane::generateResponse,
   oHitActiveArea was only set to be true if a hit was created, even if
   the track did hit material.

   The solution was to modify XYPixelPlane::generateResponse so that
   it oHitActiveArea means that the track hit any material.  I have 
   done this.

2) trk_make_siz_strip_hit.F
   The main return point, returned a stale error code!  This is now fixed. 
   This bug never bit us because everything that calls 
   trk_make_siz_strip_hit.F presets error=0 before calling it - 
   so the stale value has always been correct.

-------------------------------------------------------------------------------
February 4, 2000 Rob Kutschke

1) Bug fix to trk_make_ftrk_hit.F
   In the submission of Jan 25,	I took out the dead area computation
   because it was not done properly for the rotated planes.  It is
   now done correctly and has been put back in.

-------------------------------------------------------------------------------
January 27, 2000 Rob Kutschke

These are the last changes before v5_0.

Silicon strips implemented as siz_rects may now be rotated. 
siz_rect devices can now be specified in the .db file as having a single
wafer per plane.  Previously this was forbidden if any part of the
wafer intruded into the central hole/gap.  The specific configuration
of one large wafer is now allowed - the gap is still there, implicit
in the layer information, even though it is not present in the wafer
information.

1) geo_trkorder_siz_rect.F - compute xmin,xmax,ymin,ymax of zplane
                             for a rotated pixel plane.  This is needed
                             to stop C++ tracing from clipping the active
                             area.
2) load_siz_rect.F - Implement the case of speci="ONE".  This is what
                     allows the treatement of single wafers with an 
                     implicit gap.  Also fix a bug in the computation
                     of the correct number of segments - a factor of
                     0.5 was in the wrong place.  The bug only bit if
                     (coord0_x,coord0_y) were distinct from (xmin,ymin).

3) trk_make_siz_strip_hit.F - implement rotated planes.

-------------------------------------------------------------------------------
January 25, 2000 Rob Kutschke

This is part 1 of the changes to make rotated forward tracking planes.

The main change was to define two types of forward tracking planes.
Type 2 and type 3.  The old style, which did not really have a well 
defined type is now declared to be type 1.  For backwards compatibility
all other values of the type variable will be treated as type 1.
I have added a detailed discussion of the meaning of the various types
in the mcfast geometry documentation.

   The changes include:
1) load_ftrk.F
   Compute cell_size differently for the two new types.  For type 1, also
   fix a bug which caused cell_size to be computed incorrectly if the
   planes were not centered at zero.

2) geo_ftrk_xy_limits.F 
   A new routine in util/src.  This routine computes the true xy extent
   of a rotated plane.  

3) geo_trkorder_for_trk.F
   Set zplane_par(i).xmin, xmax, ymin, ymax from geo_ftrk_xy_limits
   rather than just copying from the ftrk_par array.  Also do this
   for the absorbers associated with the forward trackers.

4) trk_find_ftrk_plane.F and trk_make_ftrk_hit.F
   Implement types 2 and 3.  Handle all other types the old way.

5) for_trk_lyr_struct.inc
   Update comments.

6) mcfast/simulator/doc/geometry.ps
                       geometry/geometry.tex
                               /ftrk*.fig     ( new files )
                               /ftrk*.eps     ( new files )
   These were all updated to describe the new types:

7) Work still to do:
   load_ftrk.F     - there is still a bug which makes the type 1 calculation
                     of the cell size wrong for most stereo angles
   geo_fill_ftrk.F - Needs to be updated to mirror the changes in load_ftrk.F
   trk_make_ftrk_hit.F - the active area is still not quite properly defined.
                       - there is no check for being on the edge of the
                         non-instrumented direction.

-------------------------------------------------------------------------------
January 22, 2000 Rob Kutschke

1) I modified klm_fit_ftk_do.c and klm_fit_ftk_one_pass.c to automatically
   compute the seed for the second pass of the fit from the first
   pass.  If the caller calls klm_fit_ftk_do with a non-NULL pointer 
   to a second pass seed, this seed is used.  If the pointer is NULL
   then the automatically computed seed is used.
   This new functionality is protected against users doing
   silly things.

2) I modified klm_fit_ftk.c to turn on the computation of residuals
   when ftk_diag is selected in the command file.  A check
   for a weird, but legal, combination of control flags was removed.

3) I improved the cuts to select tracks for histograms 31 to 35 in
   klm_ftk_diag.F.  This included adding an icov argument and
   modifying klm_fit_ftk.c to add the argument to the call.

4) fitters_prototypes.inc was modified to add arguments to 
   klm_ftk_diag.F and klm_fit_ftk_one_pass.c

5) I also took the opportunity to update comments and to remove some 
   checks for weird, but legal, combinations of control flags.

-------------------------------------------------------------------------------
January 13, 2000 Rob Kutschke

 This note includes changes committed in over the past few days.

1) Changes were made to the ftk Kalman filter so that it would
   run in standalone mode without any reference to any of the
   mcfast internal commons.

   a) Previously the kalman filter got its magnetic field info
      from a call to trk_next_bfield.  Now that call is made 
      at the time that the node list is set up and a pointer to the
      field information is stored in the nodes.  The Kalman filter
      consults the nodes to get the field.
   b) I defined a new device type, jdev_silplane.  This
      denotes pixel planes which are really strip detectors, ie
      nsegm_x=1 or nsegm_y=1.  This removed the need for the Kalman filter
      to access the geometry database to look up nsegm_x and _y.
      For purposes of the geometry file and tracing etc, these devices
      are still siz_rect devices.  The only differences is the code
      stored in hit.chan.devtype for these devices.
   c) I removed unnecessary #include "stdhep.h" references, so that 
      the standalone code is independent of stdhep.
   d) Many routines needed changes of the form:
       if ( type .eq. jdev_pixelplane .or. type .eq. jdev_silplane ),
      in order to catch the new device type and treat it as it had
      always been treated.

2) I committed a diagnostics package for the ftk kalman
   filter.  This is switched on/off with the ftk_diag command file card.
   This diagnostics package also works in the standalone environment.

3) All of the c routines in the kalman filter package were cleaned up.
   Most of the work was done to minimize wasted space and to minimize
   time wasted allocated and freeing large chunks of memory on each call.

The changes sorted by routine are:

devtype.h                - Add new type, jdev_silplane.
devtype.inc              - Add new type, jdev_silplane.

trk_make_siz_strip_hit.F - Make device type jdev_silplane, not 
                           jdev_pixelplane.

fit_params.h             - New file. Clone of fit_params.inc.
fit_params.inc           - Update comments to warn about new fit_params.h. 

fitters_prototypes.h     - Remove klm_ftk_diag.  Add klm_ftk_diag_.
                           The old function was never committed to cvs.
                           The new one has a slightly different calling
                           sequence.
                           Add several new functions.
klm_control_struct.h     - Change direction variable to a tagged enum.
klm_node_struct.h        - Add bfield pointer to the structure.

klm_fit_ftk.c            - Clean up memory management.
                           Put bfield into the nodes.
                           Add call to diagnostic routine.
klm_fit_ftk_do.c         - More symmetric treatment of how the starting
                           parameters for the two passes are passed in.
                           Overall cleanup.
klm_fit_ftk_one_pass.c   - New treatment of bf.  
                           Add entry points to set/get starting
                           errors on the track parameter.
                           Overall cleanup.
klm_ftk_residual.c       - Make derv and derv2 static.  Now that are
                           not reallocated and freed with each call.
klm_ftk_smooth.c         - Make some arrays static to save on allocation time.
klm_addhit_ftk_cov.F     - Got rid of all references to the geometry 
                           commons.
                           a) Use jdev_silplane not nsegm to identify
                              strip detectors.
                           b) Drop barrel type devices, that had never
                              been fully implemented anyway.  They contained
                              references to the geometry commons.
                           c) Add warning if we try to use an 
                              unimplemented device.
klm_ftk_diag.F           - New file.  This does kalman filter diagnostics
                           on track level quantities.
klm_ftk_res_diag.c       - New file.  This does diagnostics on hit residuals.

klm_select_origin.F      - Check for jdev_silplane devices.
pfit_addhit_ctk_cov.F    - Check for jdev_silplane devices.
pfit_addhit_ftk_cov.F    - Check for jdev_silplane devices.
                           Stop using nsegm to identify strip devices.
pfit_addhit_wtk_cov.F    - Check for jdev_silplane devices.

-------------------------------------------------------------------------------
December 21, 1999 Rob Kutschke

Today I restored the correct behaviour of mcp_nextevent.
The error was introduced on March 26, 1999 and the code had been
correct before that.

This function selects the number of background events to read along
with the signal event.  The new version does the following:

The mean number of background events is specified by the card:
int_crossing    N

mcp_nextevent will read one event from the signal file.  It will
pull a number, M, from a Poisson distribution of mean N and it will
read M events from the background file.

This is not a fully correct implementation since it does not allow
more than 1 signal event.  However it is correct in the limit that
the number of signal events per beam crossing is much less than 1.

The erroneous method picked M from a Poisson distribution of mean N.
It required N.ge.1 or it picked another M.
It then read 1 signal event plus (M-1) background events.  This
underestimates the number of background events which accompany a signal
event.

-------------------------------------------------------------------------------
November 17, 1999 Patricia McBride

    I made the following changes to update the version for operation on LINUX
    after checking that all common blocks were aligned.
    
1)  aligned structures by adding a dummy integer where necessary
	Structures changed:
		in inc/event/ bfield_struct
		in inc/event/ long_vtx_struct
		in inc/event/ offline_shower_struct
		in inc/event/ offline_track_struct
		in inc/event/ short_vtx_struct
		in inc/event/ trace_struct
		in inc/event/ track_kine_struct
		in inc/geom/  det_structure
	updated .inc, .h, .hh, and dst output

2)  consolidated and changed the name of the offline_track and ranseed common blocks to
    be consistent with auto DST generation

3)  updated the DST output template(mcfdat.dst), usr_mcfio_out.F and McfReadEvent.c
    to remove unused common blocks.  
    
    Now using DST version 101
    Default DST output:  hit_trk, trace, hep_trace, offline_track, ranseeds
    (geometry, hepevt, calorimeter hits are handled separately-- see usr_mcfio_out)

-------------------------------------------------------------------------------
November 16, 1999 Rob Kutschke

Miscellaneous bug fixes to c++ tracing and to geometry files.

1) fillMCParticleList.cc
   The symptom which lead to this fix was that the first particle in
   a run would never decay.
   This function was invoked before the singleton class UserSettings was 
   instantiated.  So the singleton is instantiated in fillMCParticleList.cc.
   ( It is still instantiated in its former location; since it is a singleton
     that is OK. )

2) MCParticle.cc
   It was observed that in the btev detector, a B0 going near eta=0
   would never decay!  This uncovered two bugs, 2) and 3).

   Fix the logic for handling decays.  Previously, the decay of
   a particle took two steps to implement 
     - step N-1 limited the step length to the decay length but did
       not mark the particle as decayed.
     - on step N the particle "overruns" its decay length is marked
       as decayed.
   The bug was that, if there are ways to never take step N, then the
   the particle is never marked as decayed - it just magically stops.
   So its daughters are never generated.
 
   The fix was to mark the particle as decayed at the end of step N-1.

3) XMediaTracer.cc, YMediaTracer.cc
   Julia fixed these. The symptom was that the x planes and y planes
   which represent the dipole iron were never found by the tracers.
   An offset of -1 was needed to switch between an "iterator" and a 
   "reverse_iterator".

4) dbinf.F
   The symptom was that tabs in .db files caused errors in decoding the
   file.  The fix is to turn tabs into spaces as soon as each character
   is read.

-------------------------------------------------------------------------------

June 16/17 1999, Julia Yarba

The first two fixes below are TEMPORARY and very artificial. The problem is 
that in case of generating tracepoints at barrel svx the system was saving 
along with the tracepoint normal to r-plane at the point where particle hits 
while there should be normal(s) to actual wafer(s) particle hits. A similar
thing was happening when mscat/dedx was performed in barrel svx.
The problem is related to the fact that no more than one detector and no more
than one detector is allowed to be associated with each medium while in case
barrel silicon particle may hit more than one wafer (in case of overlapping).
This feature of the scheme also causes one more issue. Even is particle hits
more than one wafer, mscat/dedx can be performed only once. There's no "cheap"
way to fix this problem.   
Doing it ALL right will probably involve some modification of the scheme.

1) DetBarrelSilicoLayer.cc ( method generateResponse )
   - when indicating which wafer(s) of a given layer particle is going to hit
     the system extracts among other info the correct normal(s) to wafer(s);
     after the tracepoint is generated with the "wrong" eta(s)(eta=normal) 
     they are reset to the correct values.

2) AssociatedMaterial.cc ( method interactWith )
   - to perform mscat/dedx, the correct eta is extracted from the last
     tracepoint in the list. This is very ugly and in general unsafe but
     for the moment detector response and the corresponding tracepoint are
     generated right before the materail effect is applied. No tracepoints 
     are generated in-between. Because of this the fix is valid for the
     moment. 
     Since the tracepoint corresponding to mscat/dedx is also generated
     with "wrong" eta, the eta is then artificially reset to the correct
     value.

3) MCParticle.cc
   - now turn and stepcount are updated and checked if valid right after
   particle makes a step ; if either stepcount or turn exceeds limit (default 
   if not reset by user), the previous wtrack info for the particle is restored
   and tracing loop breaks. It means that most of the particles will not
   overcome limits; instead they will be one step short from the limits. 
   From now, it all happens in method stepBy; previously updating was
   in endStep, checking for validity was in checkStep which in fact meant
   checking previous step. 
   The problem showed up on low energy tracks with no curlers allowed (with
   curlers allowed everything looked OK). By the way, the system knows that
   user wants curlers if in the command file trk_max_turns is set >0.5.
   This is a bit odd and I'm not sure is documented. 
   
4) One more temporary fix made previously (March/April 1999 ?) that needs 
   to be remembered. I can't remember by heart what classes it involved
   but certainly I can look back and recall. The fix was meant to avoid
   unnecessary mscat/dedx if particle falls into inner gap of forward
   tracking chamber and currently deals with accessing fortran database. 
   The right way to do it is to implement a new class
   ZRectangularSurfaceWithGap : public RectangularSurface.
  
-------------------------------------------------------------------------------
May 13, 1999

1) klm_fit_ctk.F - change function name
                   move_ctk_point_cov to move_ctk_dc_point_cov
                 - remove hits_stereo and hits_sil requirements to
                   accept the track.

2) klm_fit_ctk_diag.F - Add CDF/D0 switch
                      - tune histogram limits
                      - Add histograms of error ratios for tracks with
                        silicon hits.
                      - Make histograms 10 and up only for tracks
                        with a good prob(chisq,ndof).

3) The tracks with bad prob chisq (see May 12) are due to a bookkeeping 
   error in computing the stereo drift distance.  This is being worked on.

4) The low efficiency for Psi K0s ( see May 12 ) were because
   I required 
   if ( hits_sil    .lt. trk_minhit.svx ) goto 9997
   in klm_fit_ctk.F  and many K0s daughters have no si hits.
   I made the change described in 1) to bring this code back into line
   with the pfit_fit_ctk code.

-------------------------------------------------------------------------------
May 12, 1999

Committed changes necessary to implement the ctk Kalman filter.

The conceptual changes are:

1) I discovered the the present treatment of drift chamber wires is
   not adequate.  The existing routines use a linear approximation
   to compute the drift distance, which is not good enough at low
   momentum and large abs(eta). This is true for both axial
   and stereo wires.  New routines were created to do this job 
   correctly:

      util/src/dcalc_ctk_stereo_drv_exact.F
      util/src/dcalc_ctk_stereo_exact.F
      util/src/dcalc_wtk_axial_exact.F
      util/src/dcalc_wtk_stereo_exact.F

   The following routine was changed to call the _exact wtk routines, rather
   that the original wtk routines:
      track/src/trk_make_drift_hit.F

   The exact ctk routines are used in the Kalman filter.  There is
   no axial ctk routine since the coordinate system used inside the
   Kalman filter is centered on the axial wire itself and, therefore,
   the linear approximation is exact.

   The linear versions of the stereo derivatives were good enough and
   did not need to be changed.  However the exact distance calculation
   does most of the hard work needed to compute the exact derivatives.
   So the exact ones are used anyway.

2) The origin versions of the derivative routines were found to be
   adequate for both silicon barrel and forward silicon devices.

3) The transport derivatives deriv_ctk_point have some very small differences
   wrt the cleo versions.     However either version performs adequately 
   and all distributions look fine with either.  Most of the differences
   are cases in which the cleo version returns a very small number but the
   deriv_ctk_point version returns identically zero.  I have no idea
   which, if either, is correct because I have not checked the code
   in detail.

4) It was useful to change the meaning of the following two routines:
     util/src/dcalc_ctk_zplane.F
     util/src/dcalc_wtk_zplane.F

   They used to return an (xy) distance of a point from the origin
   as measured in the world coordinate system.  They now do it in a 
   coordinate system which is attached to a wafer.  These routines
   have never been called before.  The ctk routine is now used in the
   Kalman filter and the wtk routine was changed for compatibility.

5) The following routine was substantially rewritten.  The information 
   stored in the hit_trk structure was not the information needed for
   the Kalman filter.  Also the computation of the measured quantity
   was simplified for the type 4 wafers.  This routine has only been
   checked with type 4 wafers.

     track/src/trk_make_sidisk_hit.F

6) The mainline of the Kalman filter is in the routines:

     fitters/src/klm_fit_ctk.F
     fitters/src/klm_addhit_ctk_cov.F

   The new utility routines are:
     fitters/src/klm_select_origin.F
     util/src/ctk_add_delta.F
     util/src/ctk_dedx_cov.F
     util/src/move_ctk_dc_point_cov.F

   The modified utility routines are:
     util/src/ctk_mscat_cov.F

   The modified routine now returns its status as a function value,
   instead of being called as a subroutine.

7) I have added a routine to make diagnostic histograms.  It is disabled
   by default:

      fitters/src/klm_fit_ctk_diag.F

8) Miscellaneous changes:

     fitters/src/fctl_offline.F     - add logic to call klm_fit_ctk
                                      pfit_fit_ctk depending on the value of
                                      fit_lkalman
     fitters/src/fctl_init.F        - initialize variables to control
                                      calls to diagnostics.  Default=.FALSE.
     fitters/src/pfit_fit_ctk.F     - change syntax of call to ctk_mscat_cov
     gen/src/mcp_read_cmd.F         - read in control cards to enable
                                      the calls to the diagnostics
     inc/event/fit_params.inc       - define common block variables to
                                      enable ctk or ftk fitter diagnostics.
                                      The ftk diagnostics are not yet in cvs.
     inc/geom/sib_plane_struct.inc  - update comments only

9) In the process I accidentally overwrote move_ctk_point_cov.
   I restored the correct version.

The known remaining problems that I am working on are:

1) About 1.5% of the tracks have horrible chisq.  These are not
   tracks which bremmed or had elastic hadronic interactions.
   True in both CDF and D0 detectors.  True with multiple scattering
   on or off.  True with updating on or off.

2) The efficiency for the Kalman filter version for Psi K0s is low.
   This may be a silly bookkeeping problem or a real one.

3) The forward silicon disks have a possible problem in the
   way that they compute the wafer origin.
    a) the live area does not start at 0, unless the dead area
       is explicitly zero.
    b) If there are 2 wedges per layer and type=4 there is a divide by
       zero.  However this is a nonsensical configuration with  a wedge of
       zero area - so I am not sure what we will do about this.

Summary of routines:

1) New routines:
     util/src/ctk_add_delta.F
     util/src/ctk_dedx_cov.F
     util/src/dcalc_ctk_stereo_drv_exact.F
     util/src/dcalc_ctk_stereo_exact.F
     util/src/dcalc_wtk_axial_exact.F
     util/src/dcalc_wtk_stereo_exact.F
     fitters/src/klm_addhit_ctk_cov.F
     fitters/src/klm_fit_ctk.F
     fitters/src/klm_select_origin.F
     fitters/src/klm_fit_ctk_diag.F
     util/src/move_ctk_dc_point_cov.F

2) Changed routines
     util/src/dcalc_ctk_zplane.F       - Work in new coordinate system.
     util/src/dcalc_wtk_zplane.F       - Work in new coordinate system.
     util/src/ctk_mscat_cov.F          - return a function value
     track/src/trk_make_drift_hit.F    - call the _exact routines
     tracl/src/trk_make_sidisk_hit.F   - major changes 

     fitters/src/fctl_offline.F        - add call to klm_fit_ctk.
     fitters/src/fctl_init.F           - initialize new variables
     fitters/src/pfit_fit_ctk.F        - new syntax to call ctk_mscat_cov
     gen/src/mcp_read_cmd.F            - add new parameters for diag
     inc/event/fit_params.inc          - add 2 new variables
     inc/geom/sib_plane_struct.inc     - update comments

