\def\nextline{\unskip\nobreak\hfill\break}
\documentstyle[12pt,$MYTEX/hangcaption]{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagestyle{empty}
\begin{document}
\topskip 2cm 

\section{Vertex Fitting in Mcfast}

To use the fitting routines, the user fills the {\small TRACK\_KINE} bank with
tracks (either from offline tracks or {\small HEP tracks}) and calls the fitting
routines.  The vertex fitting routines currently work in a solenoidal 
magnetic field, a dipole field in the x or y direction or a field-free region.  
The user in is control of which tracks are used to fit primary and secondary
vertices.  Finding multiple vertices requires that the user call the vertex
fitting multiple times.  Caution: this is not a vertex finder.
New particles can be built using the vertex fitter, and those tracks used in
subsequent fits.

The algorithm and implementation of the algorithm used are based on code 
written for CLEO by Paul Avery\cite{Avery}.  The extention for the vertex
fitting to work in a dipole field (x or y direction only) is accomplished by
rotating the tracks and magnetic field to point in the z direction.  A
procedure for fitting in a generalized magnetic field may be available in the
future.
The source code exists in \$MCFAST\_DIR/src/vertex.

\subsection{Initializing the Vertexing}

The routines which must be called at initialization are described below. 
Code fragments that demonstarte the calls are shown in Figures \ref{code:init1}
and \ref{code:init2}.\nextline\nextline
{\bf ksub\_set\_bfld.F}:  sets the bfield, pass in magnetic field, and a flag 
                    indicating if the magnetic field is in tesla (true) 
                    or kgauss (false).\nextline\nextline
{\bf ksub\_init.F}:     Initialization routine to set up vertexing
                        parameters like number of iterations.\nextline


\begin{figure}
\begin{tt}
\begin{verbatim}
#include "bfield_struct.inc"
#include "solenoid.inc"
#include "track_kine.inc"
      record /bfield_struct/ bf
      
      call vzero(origin,3*FLOAT_WORD)  
      call get_bfield(origin,bf)     !Find vertex at the origin
      call ksub_set_bfld(bf,.true.)           
      call ksub_init()
\end{verbatim}
\end{tt}
\hangcaption{Example code for initializing the vertexing
 a detector with a single 
solenoid or a dipole with
the field in the x or y direction covering the vertex
region.
}
\label{code:init1}
\end{figure}

\begin{figure}
\begin{tt}
\begin{verbatim}
#include "bfield_struct.inc"
#include "track_kine.inc"
      record /bfield_struct/ bf

      bf.bmag = 0.
      bf.bdir(1) = 0.
      bf.bdir(2) = 0.
      bf.bdir(3) = 1.
      bf.type = 0.           
      call ksub_set_bfld(bf,.true.)           
      call ksub_init()

\end{verbatim}
\end{tt}
\hangcaption{Example code for initializing the vertexing for a detector 
without a magnetic field.
}
\label{code:init2}
\end{figure}

\subsection{Adding Tracks to the List of Particles to Fit}
Routines for adding tracks to the {\small TRACK\_KINE} list are detailed 
below. The structure of the {\small TRACK\_KINE} list is give
in Figure \ref{code:trkkine}. Before
the vertex fitting is called, the user is responsible for filling an array with
the list of tracks to be used by the fitting.  The tracks can be from the
offline track bank, the {\small HEP} particle list, or tracks built 
from a previous vertex fit.
\begin{figure}
\begin{tt}
\begin{verbatim}
c     Track parametrization for general use (analysis, vertex fitting,
c     kinematic fitting)

c  modified 10/6/94 A.Boehnlein, added w0,class,pos_info,fixed_mass,id
c  modified 10/31/94 ASB added CLEO like track definitions 
c  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
c    These parameters describe where the tracks come from

      integer jtrk_hep, jtrk_kine, jtrk_central, jtrk_forward
      integer jtrk_offline,jtrk_anlcccsh,jtrk_anlcxbg

      parameter (jtrk_hep = 1)          !Track comes from HEP common
      parameter (jtrk_kine = 2)         !Track comes from kinematic fitting
      parameter (jtrk_central = 3)      !Track comes from central fitted list
      parameter (jtrk_forward = 4)      !Track comes from forward fitted list
      parameter (jtrk_offline = 5)      !Track comes from offline fitted list
      parameter (jtrk_anlcccsh= 6)      !Track comes for ANLCCC shower list
      parameter (jtrk_anlcxbg = 7)      !Track comes from ANLCXB gamma list
c  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

c     Only the first 7 parameters are used in fitting.

#include "const.inc"
#include "wtrack_struct.inc"

      structure /track_kine_s/
        record /wtrack_struct/ w0 !unconstrained track parameters
        record /wtrack_struct/ w  !Track parameters after fit
        DFLOAT mass               !Mass
        DFLOAT cov(7,7)           !Covariance matrix
        integer icov              !0 ==> covariance matrix not defined
                                  !1 ==> covariance matrix defined
        integer hep               !Position of corresp. track in HEPEVT list
        integer origin            !Origin of track (see definitions above)
        integer pos               !Pos. of corresp. track in original list
        DFLOAT nom_mass           !Nominal mass
        integer status            !Status (0=unmeasured, 1=measured, 2=fixed)
        integer class             !user defined class       
        integer pos_info          !0 ==>if position info not defined for track
                                  !1 ==>if position info defined for track
        integer fixed_mass        !0 ==>if particle does not have fixed mass
                                  !1 ==>if particle has fixed mass
        integer id                !particle type                           
      end structure

\end{verbatim}
\end{tt}
\hangcaption{ The kinematic track bank structure
}
\label{code:trkkine}
\end{figure}


For each event, be sure to zero out the list of tracks before adding
new tracks.  This is done most efficiently by zeroing  
the number of tracks to use in the fitting.\newline\newline
{\bf kfil\_off\_track.F}: Routine for filling the {\small TRACK\_KINE} bank 
                    from offline
                    tracks.  The user passes in the position of the 
                    desired particle in the offline\_track list and 
                    a flag indicating whether to use the {\small HEP}
                     particle
                    id (flag = 0) or use a hypothesis about the particle
                    id ($e$=1/$\mu$=2/$\pi=3$/$K$=4/$p$=5),
                    and the position of that
                    track in the {\small TRACK\_KINE} list is returned to the
                    user. The status will return non-zero on error.
                    An example code fragment is giving in \ref{code:off}
                    \nextline\nextline
{\bf kfil\_hep.F}:      Routine for filling the {\small TRACK\_KINE} list from 
                    {\small HEP}
                    tracks.  The user passes in the position of the 
                    desired particle in the {\small HEP} track list and 
                    a flag indicating whether to use the {\small HEP} particle
                    id (flag = 0) or use a hypothesis about the particle
                    id ($e$=1/$\mu$=2/$\pi=3$/$K$=4/$p$=5), 
                    and the position of that
                    track in the {\small TRACK\_KINE} list is returned to 
                    the user. This routine is
                    called as above, however remember that the {\small HEP}
                    tracks
                    have no covariance matrix.\nextline \nextline
{\bf ksub\_insert\_w.F}:  Routine for adding in $w$ track format to the 
                    {\small TRACK\_KINE}
                    list.  Used with {\bf kfit\_build\_vtx}, for example, 
                    which
                    will build a particle in $w$ track format from several
                    input tracks.  The user inputs the track in W format
                    the covariance matrix, particle type, type of position
                    information,  the origin of the track (2 for tracks
                    from kinematic fits) whether or not the mass is fixed, if 
                    the mass is to be set by the user, the value of the
                    mass if that is the case, the user defined class.  The
                    position in the {\small TRACK\_KINE} back is returned to 
                    the user.
                    The parameters for the track are listed in Figure \ref
                    {code:trkcom}.\begin{figure}
\begin{tt}
\begin{verbatim}

      trk_num = 0                             ! Clear the trk_kine list
      idtyp = 0                               ! Use STDHEP particle id
      do it = 1,trk_off_num  !add all particles from offline track list
         status = kfil_off_track(it,idtyp,ik) ! make call
         vntrk = vntrk + 1                    ! update counter
         vitrk(vntrk) = ik                    ! store position in list
      enddo
\end{verbatim}
\end{tt}
\hangcaption{Code fragment for adding offline track particles to the
list used for fitting.
}
\label{code:off}
\end{figure}

\begin{figure}
\begin{tt}
\begin{verbatim}

C   Inserts a particle in the trk_kine list.
C
C  w1        track parameters in W format (Px,Py,Pz,E,x,y,z)
C
C  cov     real array (read)
C            Covariance matrix of TRKW (assumed to be 7x7)
C
C  idtyp     Integer variable (read)
C            Particle type
C
C  pos_info      integer variable (read)
C            1  ==> position info can be used in fit
C            0 ==> position info cannot be used in fit
C  fixed_mass  integer (read)
C            1  ==> mass is fixed (fixed during track updates)
C            0 ==> mass is floating
C
C  origin   integer variable (read)
C            ===> particle origin, see track_kine_struct.inc for definitions
C
C  use_mass integer variable (read)
C            1==> use value of mass
C            0==> do not use value of mass
C
C  mass     real variable (read) 
C  class    Integer variable (read)
C            User defined ID number ()

example call:
      record /wtrack_struct/ track
      DFLOAT vtrack(7,7)
          ....
      status = ksub_insert_w(track,vtrack,id,1,0,2,0,0.,0,ik) 
                                
\end{verbatim}
\end{tt}
\hangcaption{Description of the track parameters used by the vertex fitting.
}
\label{code:trkcom}
\end{figure}

\subsection{Routines that do the Vertex Fitting}

There are three main user called routines for fitting a vertex.  One will just
fit a vertex, the other will fit a vertex and return a ``track'' built from
that vertex. The third option is to constrain the vertex to a known beam
position.
 Some information is returned from the calling routine, like the
position of the vertex, the errors and the $\chi^2$.  Additional information
can be obtained from the {\small KINE\_CHI.INC} common block shown in Figure
\ref{code:kinechi}.\nextline\nextline
{\bf kvtx\_3d}: Routine for doing the fitting.  The user supplies the
                    number of tracks and an array of track positions in 
                    the {\small TRACK\_KINE} list for fitting.
                    The user also supplies flags (listed in \ref{code:flags}),
                    and an
                    array for the vertex and an array for the vertex covariance
                    matrix, and $\chi^2$.  A code fragment example of a call is
                    given in Figure \ref{code:kvtx}.\nextline \nextline
{\bf kfit\_build\_vtx}:  Builds a particle out of several particles using a 
                   vertex constraint.  The user supplies the number of tracks,
                   an array pointing to those tracks in the trk\_kine list, an 
                   array specifying the position information of the track, 
                   whether or not to update the tracks according to
                   the vertex fit, a z vertex position, 
                   covariance matrix for the vertex, a flag for deciding
                   whether or not to compute the covariance matrix for the new 
                   particle, and the track parameters, covariance matrix for 
                   the track and chisq is returned to the user.  The user 
                   also passes in the dimension of the covariance matrix, at 
                   least 7. These flags are shown in Figure \ref{code:build}.
                   A code fragment is shown in Figure \ref{code:doit}
                   \nextline\nextline
{\bf kvtx\_beam\_constraint}:  This routine is called similar to above, but in
                             addition, a vertex and error matrix for that
                             vertex is supplied as well.  The algorithm used is
                             to find the vertex with minimum $\chi^2$ for
                             the specified tracks and then to ``average'' that
                             vertex with the constraint vertex
                             The ``averaging'' is sensistive to the
                             errors on both vertices.   The $\chi^2$ is updated
                             and the vertex is returned with errors.  For
                             example, if the
                             known {\small HEP} beam position is used with no
                             errors, the returned vertex will be the {\small
                             HEP} beam position with a zero covariance matrix,
                             but with a $\chi^2$ calculated for that position.
                             In this case, if specified, the constrainted
                             vertex position will be used as the starting point
                             of the fit.
                             An example of a call is shown in Figure
                             \ref{code:constraint}
                             

\begin{figure}
\begin{tt}
\begin{verbatim}
C  Contains info for least square fits
C
C  max_iter      Max number of iterations
C  max_del_chisq   Quit iterating when change in chisquare < CHDELF
C
C  nconf      # of constraints
C  ndegf      # of degrees of freedom
C  iterf      actual number of iterations used in fit
C  choldf     value of chisquare at last iteration
C  chif       final chisquare
\end{verbatim}
\end{tt}
\hangcaption{Description of {\small KINE\_CHI.INC}.
}
\label{code:kinechi}
\end{figure}

\begin{figure}
\begin{tt}
\begin{verbatim}
UPDATE: 
C          0 ==> do not update input track parameters (just calculate chisq)
C          1 ==> update input track parameters only
C          2 ==> update input track parameters & covariance matrices and
C                replace the original unconstrainted parameters by the
C                new ones. ****** This is a dangerous option. ******

C  LUSEZ   logical variable (read)
C          TRUE  ==> use the value of Z as the starting value
C          FALSE ==> compute the starting value with a straight line approx.

\end{verbatim}
\end{tt}
\hangcaption{Description of the flags used by the vertex fitting.
}
\label{code:flags}
\end{figure}
 
\begin{figure}
\begin{tt}
\begin{verbatim}
      integer vntrk,vitrk(max_trk),update
      logical lusez
      DFLOAT Z(3), VZ(3,3), chisq
        ....

        ....
      update = 0
      lusez = .false.
      z(1) = 0.0
      z(2) = 0.0
      z(3) = 0.0
      call vzero(vz,3*3*FLOAT_WORD)
      status = kvtx_3d(vntrk,vitrk,update,lusez,z,vz,chisq)

\end{verbatim}
\end{tt}
\hangcaption{Code fragment showing a call to the vertex fitter.
}
\label{code:kvtx}
\end{figure}

\begin{figure}
\begin{tt}
\begin{verbatim}
C  IVOPT     Integer array (read)
C            IVOPT(IL) = 0  => Track ITRK(IL) has no position info at all
C            IVOPT(IL) = 1  => Track ITRK(IL) is not used to determine vertex
C                              but is constrained to pass through vertex
C            IVOPT(IL) = 2  => Track ITRK(IL) is used to determine vertex
C
C
C  LCOVAR    logical variable (read)
C            TRUE  ==> compute PW covariance matrix
C            FALSE ==> do not compute PW covariance matrix
C
C *PW        real array (write)
C            Fitted particle in W format (Px,Py,Pz,E,X,Y,Z)
C
C *VP        real array (write)
C            Covariance matrix of PW
C
C  MVP       integer variable (read)
C            First dimension of VP (must be at least 7)

\end{verbatim}
\end{tt}
\hangcaption{Code fragment showing a flags to the track builder.
}
\label{code:build}
\end{figure}

\begin{figure}
\begin{tt}
\begin{verbatim}
             ...
      logical lcovar
      integer mvp,ivopt(2)       
      parameter (mvp = 7)
      DFLOAT vtrack(7,7)
      record /wtrack_struct/ track
              ....
      ivopt(1) = 2
      ivopt(2) = 2
      update = 1
      lcovar = .true.
      call vzero(vz,3*3*FLOAT_WORD)
      call vzero(vtrack,7*7*FLOAT_WORD)
      call vzero(track,WTRACK_WORD)
      call vzero(z,3*FLOAT_WORD)
      nbvert_good = 1
      if (nb_to_vertex.eq.2) then
         nbvert_good = kfit_build_vtx(nb_to_vertex,btrack_to_vertex,
     &                ivopt,update,z,vz,lcovar,chisq,track,vtrack,
     &                mvp)

\end{verbatim}
\end{tt}
\hangcaption{Code fragment showing a call to the vertex fitter and
track builder.
}
\label{code:doit}
\end{figure}

\begin{figure}
\begin{tt}
\begin{verbatim}
             ...
#include "prim_vertex.inc"
             ....
      logical lcovar
      integer mvp,ivopt(2)       
      parameter (mvp = 7)
      DFLOAT vtrack(7,7)
      record /wtrack_struct/ track
              ....
        update = 1
        lusez = .TRUE.
        z(1) = 0.0
        z(2) = 0.0
        z(3) = 0.0
        zi(1) = prim_vertex(1,1)
        zi(2) = prim_vertex(2,1)
        zi(3) = prim_vertex(3,1)
        call vzero(vzi,3*3*FLOAT_WORD)
        status = kvtx_beam_constraint(vntrk,vitrk,update,
     &                         lusez,zi,vzi,z,vz,chisq)
        
\end{verbatim}
\end{tt}
\hangcaption{Code showing use of constrainted fitting on known beam spot. 
If the covariance matrix is known for the vertex used as a constraint, it
should be supplied.  In this example, the known vertex is used as the starting
point for the fit (note that lusez is true) and the momentum and position of
the tracks are updated to reflect the constrainted fit.
}
\label{code:constraint}
\end{figure}
\subsection{Update history}
This document was created on 10/24/94 by A. Boehnlein.\newline
Updated 4/06/95 A. Boehnlein\newline
Updated 5/06/96 A. Boehnlein\newline
Updated 6/11/96 A. Boehnlein\newline
Please send comments, requests for clarification, or errors 
in this document or the vertexing code to Amber Boehnlein,
Cope@fnal or (708)840-2937.

\begin{thebibliography}{99}
\bibitem{Avery}P.~Avery, http://www.phys.ufl.edu/\~avery/html
/fitting.html and private communication.
\end{thebibliography}

\end{document}
