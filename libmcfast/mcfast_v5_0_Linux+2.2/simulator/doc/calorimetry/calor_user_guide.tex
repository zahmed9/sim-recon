%\documentstyle[12pt]{article} 
%\pagestyle{plain}
\documentstyle[12pt]{article} 
\oddsidemargin=5mm
\evensidemargin=-5mm
\topmargin=0mm
\headheight=0mm
\headsep=0mm
\textheight=210mm
\textwidth=165mm
\title{User's Guide for Showering/Calorimetry in MCFAST \\
(version 4.1.0 and above) }
\author{Julia Yarba}
\begin{document}
%\pagestyle{empty}
\bibliographystyle{plain}
\maketitle
\section{Introduction}
This documents serves as a user's guide and reference manual for the
showering/calorimetry subpackage in MCFAST. 
This subpackage is completly integrated into
MCFast Monte-Carlo pacakge: the user defines tracking systems and 
calorimeters and absorbers on equal basis, and  MCFast takes care 
of converting particles to shower
automatically, through ad-hoc interruption of the tracing processes. 
In addtion,energy losses in the bulk material of the calorimeters and 
absorbers are taken into account. 
As other features of MCFAST, the showering simulation is based on an extensive
parametrisation scheme.  That is, there is no detailed, particle by particle,
description of an  electromagnetic or hadronic shower.  Instead, the energy
densities due to the high energy showering processes within volumes 
are parametrised, and shower fluctuations are simulated  globably rather
than locally. Then in calorimeters these energy densities are mapped onto 
a user-controlled $x$-$y$ or $\eta$-$\phi$, or $z$-$\phi$, or $r$-$\phi$ grid, 
and calorimetry hits are generated.  
 
\section{Method \& algorithm}
\subsection{Geometry}

Unlike particle tracing in MCFAST, the simulation of the shower propagation is
intrinsically 3-dimensional. 
\par
To keep the program simple, only 3 volume  types
are recognized: BOX, TUBE and CONE. These shapes must be oriented  in such a
way that the symmetry axis is oriented along the Z-axis. 
\par
It should be pointed out that MCFAST, originally written in FORTRAN77,  
is undergoing an extensive modernization and migration to C++ programming language.
This allowed to upgrade hit generation in calorimeters and thus singificantly 
improve the speed of the code, while the basic concepts and alogirithms for 
showering simulation have been kept unchanged.
However, the process of upgrading MCFast has not been completed yet, and thus only TUBE 
and BOX shaped volumes have been implemented in the C++ release so far (the task extends beyond
showering simulation and is mostly related to the tracing part of the package).
\par
These volumes are filled with a user-specified material, where showering 
occurs (electromagnetic and/or hadronic).  
Up to 40 such volumes can be defined in an MCFast job. 
In calorimeters, the segmentation is mapped to variables of physical interest,
such as z or radius of particle, or the pseudo-rapidity $\eta$ and azimutal 
angle $\phi$, or $x$-$y$ for forward calorimeters.
Please note that the $z$-$\phi$ segmentation is  valid 
for concentric calorimeters in central region only. The $r$-$\phi$ segmentation
is valid only for tube-shaped forward and backward calorimeters. 
Currently, in order to select $z$-$\phi$ segmentation
for a {\bf central} calorimeter user should specify parameter {\bf type} 
of EMCAL be 51; to specify $r$-$\phi$ segmentation for {\bf forward/backward}
calorimeters type should be 52 (see description of geometry definition below).  
Any attempt to set $r$-$\phi$ readout for cone-shaped forward/backward
calorimeters will end up in resetting it to $\eta$-$\phi$ by the system 
automatically.  
No provision for longitudinal segementation is given, however,
the user can implement that functionality by defining multiple calorimters, 
for a given  $\eta$-$\phi$ or $x$-$y$ range.  For a central, solenoidal type 
detector, 
these calorimetric are usually concentric, while for a forward type geometry,
they will be located at successive Z planes.  
 
\par
To initialize calorimetry/showering a user should define at least one 
calorimeter or absorber in the input geometry ASCII file in the following 
format. \\
{\bf include db/emcal.db} \\
{\bf make EMCAL name} \footnote{It is a character variable, its length
can be up to 40 characters}
{\bf shape type rmin@zmin rmin@zmax rmax@zmin rmax@zmax} \\
{\bf z\_center z\_length average\_material\_name active\_material\_name} 
\footnote{Average and active materials should be different for sampling
calorimeters and same for homogenious calorimeters; both average and active
materials must be define before they are first used; here it must be 
specified by {\bf name} of type character}  
\\
{\bf n\_coor1\_segms n\_coor2\_segms} \footnote{it basicaly means $\phi$-$\eta$
or $\phi$-$z$ (if type=51), or $\phi$-$r$ (if type=52) segmentation; 
the first values should be the number of $\phi$-segments, and the
second one is for the number of $\eta$-, or $z$-, or $r$-segments} 
{\bf a\_em b\_em a\_had b\_had e/$\pi$\_ratio nlayers} \\
for concentric calorimeters, or \\
{\bf include db/calorbox.db} \\
{\bf make CalorBox name shape} \footnote{it should be BOX; any combination of
low case or capital letters is allowed}  
{\bf xmin xmax ymin ymax } \\
{\bf xmin\_gap xmax\_gap ymin\_gap ymax\_gap } \\
{\bf z\_center z\_length average\_material\_name active\_material\_name } \\
{\bf n\_coor1\_segms n\_coor2\_segms} \footnote{this basibaly means the $x-y$ 
segmentation; the first value means the number of $x$-segments, and the second one
is for the number of $y$-segments}
{\bf a\_em b\_em a\_had b\_had e/$\pi$-ratio nlayers} \\
for box-shaped calorimeters. \\
To specify absorbers use the following. \\
{\bf include db/absorber.db } \\
{\bf make Absorber name shape type} \footnote{it should be either 1 for central
region or 2 for forward/backward region; in case 41 or 42 are specified only
energy loss via minimum ionization and multiple scattering will be performed} \\
{\bf rmin@zmin rmin@zmax rmax@zmin rmax@zmax z\_center z\_length material\_name} 
\\
for concentric absorbers,  
or for box-shaped abosrbers \\
{\bf include db/absorberbox.db } \\
{\bf make AbsorberBox name shape type} \\
{\bf xmin xmax ymin ymax z\_center z\_length material\_name} 

To turn the calorimetry off, a user should delete or comment out everything 
about calorimeters and absorbers in the input geometry file.

\subsection{Showering algorithm(s)}

At the initialisation stage, MCFast compute surface boudaries for these
volumes. At the tracing stage, once such a surface is reached, the calorimetry
subpackage returns an estimate of the mean free path length for the particle.
For electrons/positrons and  gammas it is simulated according the formula $f(x)
= e^{-x/X_0}$, $X_0$ is  radiation length. For hadrons $f(x)=e^{-x/\lambda}$,
$\lambda$ is absorbtion  length (the mean free path for inelastic
interactions).  Based on this information and random number(s), the interaction
inside the  calorimeter is computed,  if need be.  Should that primary
interaction occur,  the trace identity switches from ``elementary particle'' to
``shower'', the core of that shower is propagated across the geometry by the
MCFast tracing routing.  This allows us to propagate a shower from one
calorimter to the next.  However, there is currently no provision for a magnetic
field inside a calorimeter. Unlike particles, the core
of the shower propagate in a straight line.

\par Upstream of this conversion point, the energy loss inside the  material is
taken into account, assuming that the particle behaves as a minimum ionizing
particle (MIP) and the corresponding energy deposition is recorded, e.g., 
calorimetry hits are created. Showering switches on at the shower conversion
point.\footnote{Defined as the point where the first hadronic or electromagnetic
high energy interaction occurs}  

Downstream of the conversion point, the fraction of ``visible energy''
is calculated for sampling calorimeters. After each step, the shower core
position and energy/momentum are estimated and the control is given to the hit 
generation if necessary (see below). The package can optionally simulate 
energy deposition to the cells surrounding the shower core 
(Transverse profile ``ON'').  

Note that a shower can spread over multiple volumes both longitudinally
and transverselly (see description of ``neighbouring'' calorimeters below).
Thus, even if a shower develops in an absorber, it still may produce hits
in nearby calorimetrs (if any). 

The electromagnetic shower longitudinal profile is described as
\begin{displaymath}
 dE / dx = E_0 b \frac{ (bt)^{a-1} e^{-bt} } { \Gamma (a) }
\end{displaymath} 
were 
\begin{displaymath}
 t = x / X_0, \qquad
 b \simeq 0.5, \qquad
 a = 1 + b t_{max},
\end{displaymath} 
\begin{displaymath}
 t_{max} = 1.0 \times (ln(y) + C_i), \qquad
 i = e,\gamma, \qquad
 (C_{\gamma} = +0.5, \qquad
 C_{e} = -0.5)  \qquad
\end{displaymath} 
\begin{displaymath}
 y = E / E_c, \qquad
 E_c = \frac{800 MeV}{Z+1.2},
\end{displaymath} 
($Z$ is atomic number, $E_0$ is energy of incident particle).

For hadronic shower we use
\begin{displaymath}
 dE / dx = E_0 (w b \frac{ (bt)^{a-1} e^{-bt} } { \Gamma (a) } 
+ (1-w) d \frac{ (du)^{c-1} e^{-du}  } { \Gamma(c) })
\end{displaymath} 
were 
\begin{eqnarray}
 t &  = & x / X_0 \nonumber \\
 u & = & x / \lambda \nonumber \\
 a & = & 0.6165 + 0.3183 ln{E_0} \nonumber \\
 b & = & 0.2198 \nonumber \\
 c & = & a \nonumber \\
 d & = & 0.9099 - 0.0237 ln{E_0}\nonumber\\
 w & = & 0.4634\nonumber  \\
\end{eqnarray} 

When the shower transverse profile is turned on,
 the energy deposited on each step is distributed around the shower axis
according to shower transverse profile (which becomes wider as shower moves 
deeper into a calorimeter). 

The transverse profile for both electromagnetic and hadronic showers is 
described as
\begin{displaymath}
 \frac{dE}{dR} = e^{(-R / A_1)} + A_2 e^{(-R / A_3)}
\end{displaymath}

In this formula, parameters $A_1, A_2, A_3$ depend of the material  properties
and on the depth the current shower depth.  Note that the dependencies are
different for electromagnetic and hadronic showers. The distribution of energy
occurs in a plane perpendicular to the direction  of motion of the shower core.
Showers may have cross particular calorimeter boundaries, both longitudinally
and transverserly.  In this case energy  deposition is also
computed in the corresponding cells of those neighboring calorimeters.  

The process stops if either :
\begin{itemize}
\item {the particle (shower) leaves the calorimeter volume}
\item {95\% (or more) of incident energy is deposited; in this case 
there is one more step, and the remaining energy is distributed according
the transverse profile at (N+1)$X_0$}
\end{itemize}

It is important to note that if a showering has started, the longitudinal path
length of the shower core inside the calorimeter is recorded.   If a shower core
leaves the calorimeter volume still carrying some energy, this information is
passed along to the simulation procedure for the next calorimeter.  Thus,  a
calorimeter accepts incident showers as well as MIPs. 

The deposited energy is smeared during the process of showering simulation according 
to the energy resolution formula
\begin{displaymath}
\frac{\sigma_E}{E} = \frac{a}{\surd E} \oplus b
\end{displaymath}
where {\large $a$} and {\large $b$} are {\bf input} parameters for the code.

For a sampling calorimeter, a visible fraction of energy is calculated (depends
on the densities and proportion by volume of material from which a calorimeter is built).

\bigskip

\subsection{Accounting for shower spread over multiple volumes}

As mentioned above, showers may spread over multiple volumes both longitudinally
and transvereselly. Longitudinally, it's basically a transport of the shower core 
from one volume to another. Transverse expansion over multiple volumes happens as
the lateral profile becomes wider and a portion of deposited energy ends up outside
of a given volume and inside a another volume nearby (if any), producing there hits
(if the nearby volume is a calorimeter).

In the latest C++ release, a list of neighbouring calorimeters is created for each
volume at the initialiuuzation stage. Note that only calorimeters are allowed in 
the list of neighbours while any volume, either a calorimeter or an absorber is
allowed to have neighbours.

A calorimeter C is considered to be a neighbour N of a volume if either their z-sides
overlap at least partially by radii, or inner surface of C overlaps at least partially 
in z with outer surface of N, or outer surface of C overlaps at least partially
in z with inner surface of N. Any tracking devices between volumes are concidered
``transperent'' for showers.  

If a portion of deposited energy is found outside a given volume, a search loop
over all neighbouring calorimeters is performed in order to find out whether the
portion of energy ends up in one of them. The loop breaks as soon as the right
calorimeter is found in order to optimize the speed of the code.

In the FORTRAN77 release, a search loop is performed over the whole list of volumes
in the system; the loop breaks once the right calorimetr is found (if any).

\bigskip

\subsection{Comparison MCFAST vs GEANT}

GEANT (with the same detector geometries and the same event input as for 
MCFAST) was used in order to compare how well data obtained with the detailed 
(e.g. GEANT)  Monte Carlo matches the parametric simulation (MCFast). 

We have made comparison MCFAST vs GEANT with a single particle incident a block of iron.
A shower may start and/or develop in the first block and two more blocks of iron. All
three blocks are of different thinknesses and $\eta$-$\phi$ segmentations.

In GEANT, standard energy cuts are used, i.e. 1 MeV for $\gamma$s and electrons, 10 MeV for
hadrons and muons (by energy cut they mean the energy at which the tracing of a particle 
of a given type stops). 
As hadronic shower generator we used GHEISHA which is the default option for GEANT.

The test is made for 10 GeV and 100 GeV $\gamma$ and $\pi$. 

The speed up factor of MCFAST over GEANT is found to be about 50 and 21 for 10 GeV $\gamma$
and $\pi$, respectively, and about 475 and 200 for 100 GeV $\gamma$ and $\pi$, respectively.

The shower conversion point generation is in a good agreement and 
the average shower transvesre profile generation is in a very reasonable 
agreement for both EM and HAD showers, comparing MCFAST vs GEANT. 

The e/$\pi$ ratio (which is an input parameter for MCFAST) may be tuned to correspond 
GEANT results.

Here it should be said that the speed of GEANT package depends pretty
much on energy cuts selection. Also, hadronic shower generator choice
affects the GEANT speed. For example, quick check indicatites that
FLUKA package is 2 times slower that GHEISHA. 

Also, those who want to compare MCFAST vs GEANT should keep in mind
that GHEISHA generates e/pi ratio that depends on the particle/shower
energy. FLUKA package does not produce this effect. It is not clear for 
the moment whether and how MCFAST should reflect this effect. The decision
will be taken in a nearest future after more detailed comparison of MCFAST
simulation results vs test beam data.

The shower conversion point and average transverse profile do not
depend on GEANT hadronic shower generation choice, but the transverse   
profile may be slightly affected by the choice of GEANT energy cuts.

At last, we would like to stress that we do NOT intend to make    
any comparison, other than mentioned, of different GEANT hadronic 
shower generators.

\subsection{Hit generation package}

In calorimeters, energy depositions in cells are recorded as a shower propagates.

However, with the ongoing upgrate and migration of MCFAST to C++, hit generation
is calorimeters go on different schemes in FORTRAN77 and C++ releases and thus
application interface methods are also different.

It should be pointed out that {\bf with the scheme implemented within the C++ 
release hit generation in calorimeters is significantly faster}. Thus the C++ 
release is strongly recommended, especially for those who are interested in 
calorimeters with fine segmentation.   

\subsubsection{Hit generation package for C++ release}

This subpackage has been written completelly in C++ and takes full advantage
of dynamic memory allocation.

A ``Hit'' refers to a total energy deposition in a cell(base class CalorSignal) 
and information on contributing tracks/particles, i.e. track number referring 
to the HEP event list along with the energy deposition via minimum ionization,
electromagnetic, and hadronic showering processes caused
by the particle/shower; the information on contributing particle is organized
as an STL vector container (class CalorSignalMC derived from class CalorSignal). 
The information on hits is stored in a two-dimensional array of pointers 
to ``Hit'' objects, with the total number of such pointers being equal to the number
of cells specified by a user for each calorimeter. 
The advantage of such approach is that as particle/shower propagates
and shower develops, indeces of affected cells are calculated and hits be accessed
directly in order to update information which in its turn allows to avoid multiple
blowing and compressing of hit lists (though this approach is not the most economical 
one in terms of memory allocation, i.e. some of the hits do not contain any meaningful
information). In each calorimeter, such array of pointers to hits is allocated dynamically 
once a particle/shower touches the calorimeter for the first time (if no particle/shower 
ever touches a given calorimeter, no array of hits is allocated in it).
The selection of the two-dimensional array of pointers vs two-dimensional array of objects
is related to the desire to create the right memory layout for users that may want 
to disregard the information on contributing particles/showers at the clusterization
stage and deal only with energy deposition in cells. 
 
\subsubsection{Hit generation package for FORTRAN77 release}

Unlike most of the original MCFAST written in FORTRAN77, the calorimetric hit generation
subpackage was rewritten in C to take advantage of dynamic memory allocation unavailable
in FORTRAN. 

Energy deposition in calorimetric cells are organized a list of ``hits''. 
A ``Hit'' refers to  a set of variables describing the cell coordinates 
and the type of energy (MIP vs E.M., vs. Hadronic). 
Once a particle/shower leaves a given calorimeter,  hits in it are collected
with respect to the segmentation of a certain granularity  specific for every
calorimeter, so that several hits produced in the same cell during showering
collapse into one. At that stage, the track STDHEP number is associated to
this collection of hits. NOTE : if during the process a showers parts touches 
a neighbouring calorimeters, hit collection occurs there, too. At the
end of each event, hits pointing  to the same cell  produced by different particles 
are looked over in
order find out segments in each calorimeter in which several particles may
have produced energy deposition (this process is called hits consolidation).
At this stage, a pointer to each track/particle that has contributed to a
given hit/cell  is also saved, along with the percentage of total energy
caused by the particle. After this all the information is given to a user for
future analysis.

\section{Reference Section}

The description of the calorimetry package methods and routines is given in the next section.
The code(s) can be found in \$MCFSRC/shower/src and \$MCFSRC/showering/src and \$MCFSRC/calorimetry/src areas. 

The language for geometry definition structures is FORTRAN77.

\subsection{Description of the User Data cards}
\subsubsection{control\_shower}
   This is set of keywords in the MCFAST command file that allow a user to set
   some parameters which control shower generation. 
\begin{itemize}
\item{ {\bf shw\_trans}\\   Default value is {\bf ON}.
   In order to further speed up the program and artficially reduce the number
   of hits generated, it is possible to create hits only the exact path 
   of the shower-core. Only cells crossing that path get energy deposition. 
 To set this option, set {\bf shw\_trans OFF}.} 
\item{ {\bf e\_thresh} \\
   The default value is 0.05.
   With the current showering algorithm we stop tracing a shower if the remaining energy
   of the shower is 5\% or less of the incident energy. But if a user wants to stop tracing 
   of a shower earlier or later, he/she can do it by setting threshold as desired.}
\item{ {\bf e\_min\_vis} \\
   The default value is 0.002 GeV. This is a minimum energy that can be recorded in 
   the calorimeter cell (currently is set once for all calorimeters). }
\item{ {\bf max\_hit\_step} \\
   The default value is 25. This is maximum number of hits with status SHOWERING (see below) 
   that can be produced over each step as shower propagates. Correlated with {\bf e\_vis\_min}
   ( nhits = min((edep/e\_vis\_min),max\_hit\_step) ); max\_hit\_step=0 is equivalent to
   shw\_trans OFF. It is up to a user to change this parameter in order to speed up the code
   but the precision of shower transverse profile generation may be affected.}
\item{ {\bf hit\_generation} \\
   The default value is {\bf ON}. This is a switch that may be turned {\bf OFF} if a user
   does not want to generate hits in calorimeters. If it is OFF, {\bf shw\_trans} also 
   turns OFF. }
\end{itemize}

\subsection{Description of the MCFAST calorimetry data structures}

\subsubsection{Geometry definition: {\bf emcal.inc \& emcal\_struct.inc}}

The include files can be found in \$MCFINC/geom area. \\
\\
{\bf integer type} - 1= central, 2= forward \\
{\bf integer seg\_type} - 0 = $\eta$-$\phi$, 1 = $x$-$y$, 2=$z$-$\phi$, 3=$r$-$\phi$ segmentation \\
{\bf character*4 shape} - can be either BOX, TUBE, or CONE \\
{\bf real rmin(2)} - inner radius at zmin and zmax respectevely 
(for CONEs and TUBEs) \\
{\bf real rmax(2)} - outer radius at zmin and zmax respectevely 
(for CONEs and TUBEs)\\
{\bf real xlimit(2)} - left and right side edge x-coordinate (for BOXes) \\
{\bf real ylimit(2)} - left and right side edge y-coordinate (for BOXes) \\
{\bf real xlimit\_gap(2)} - left and right side edge x-coordinate of inner gap
(for BOXes) \\
{\bf real ylimit\_gap(2)} - left and right side edge y-coordinate of inner gap
(for BOXes) \\
{\bf real zmin} - left side edge z-coordinate  \\
{\bf real zmax} - right side edge z-coordinate \\
{\bf real eta\_min} - lower limit of $\eta$-coverage \\
{\bf real eta\_max} - upper limit of $\eta$-coverage \\
{\bf integer ncoor1} - number of x- or $\phi$-segments \\
{\bf integer ncoor2} - number of y- or $\eta$-, or z-, or $r$-segments \\
{\bf integer material} - pointer on the ``average'' material which fills 
the calorimeter \\
{\bf integer active\_material} - pointer on the ``active'' material (for sampling
calorimeters) \\
{\bf integer nlayers} - number of layers in a sampling calorimeter (default is 1) 
\footnote{this has been implemented for GEANT based code which is under development
in parallel with MCFAST; the MCFAST itself does not use this information} \\
{\bf real siga\_em} - stochastic term in energy resolution formula for EM showers \\
{\bf real sigb\_em} - constant term in energy resolution formula for EM showers \\
{\bf real sigc\_em} - noise term in energy resolution formula for EM showers \\
{\bf real siga\_had} - stochastic term in energy resolution formula for HAD showers \\ 
{\bf real sigb\_had} - constant term in energy resolution formula for HAD showers \\
{\bf real sigc\_had} - noise term in energy resolution formula for HAD showers \\
{\bf real zerosup} - threshold on visible energy in calorimeter \\
{\bf real c\_coor1\_size} - cell size in x- or $\phi$-units \\
{\bf real c\_coor2\_size} - cell size in y- or $\eta$-, or z-, or r-units \\
{\bf character*40 name} - device name 

\bigskip

NOTE : 
The confused nomenclature ``EMCAL'' has historical roots. Hadronic
showers we added later, the names of data structure did not changed for sake of
expediency.

\subsubsection
{Basic calorimetry hit structure for C++ release : \\
CalorSignal.hh, CalorSignalMC.hh, CalorInfoTrack.hh }

The header files can be found in \$MCFSRC/calorimetry/src area. \\
{\bf class CalorSignal \\
\{ \\
...... \\
public: \\
double getE() const } - returns total energy deposition  \\
{\bf virtual void clear()} - zeros out energy deposition \\ 
{\bf ...... \\
protected: \\
double fEnergy } - total energy deposition \\
{\bf ...... \\
\} } \\
{\bf class CalorSignalMC : public CalorSignal \\
\{ \\
...... \\
public: \\
virtual void clear() } - zeros out energy deposition and erases info on contributing particles/showers \\
{\bf const vector$<$CalorInfoTrack$>$\& getInfoTracks() const} - returns a constant \\
referrence to a vector
of InfoTrack objects (see below) \\ 
{\bf double getEMIP() const} - returns energy deposition via minimum ionization \\
{\bf double getEEM()  const} - returns energy deposition via electromagnetic showering \\
{\bf double getEHAD() const} - returns energy deposition via hadronic showering \\
{\bf double getEMIP( const int ) const} - returns energy deposition via minimum ionization by given particle \\
{\bf double getEEM(  const int ) const} - returns energy deposition via electromagnetic showering by given particle \\ 
{\bf double getEHAD( const int ) const} - returns energy deposition via hadronic showering by given particle \\
{\bf ...... \\
private: \\
vector$<$InfoTrack$>$ fInfoTracks } - vector of InfoTrack objects \\
{\bf ...... \\
\} } \\
where \\
{\bf struct CalorInfoTrack \\
\{ \\
int trackID } - track number referring to the HEP event list \\
{\bf double EMIP } - energy via minimum ionization the track causes \\ 
{\bf double EEM } - energy via electromagnetic showering the track causes \\ 
{\bf double EHAD } - energy via hadronic showering the track causes \\ 
{\bf ...... \\
\} }      

\subsubsection
{Basic calorimetry hit structure for FORTRAN release : {\bf cal\_hit.h}}

The include file can be found in \$MCFSRC/shower/src area. \\
\\
{\bf int icr1} - $x$ or $\phi$ cell number for the hit \\
{\bf int icr2} - $y$ or $\eta$ cell number for the hit \\
{\bf float e\_mip} - amount of energy deposited through ionization \\
{\bf float e\_em} - amount of energy deposited through EM processes \\
{\bf float e\_had} - the amount of energy deposited through HAD processes \\
{\bf int status} - word defining the hit status, see below \\
{\bf int n\_tracks} - number of tracks contributing to this hit \\
{\bf cal\_hit\_tracks *info\_track} - pointer to set of track vs calorimetry 
hit, \\
where \\
{\bf cal\_hit\_tracks} is a structure containing : \\
{\bf int tr\_num} - track number referring to the HEP event list \\
{\bf float percent\_e\_tot} - percentage of the total hit energy this track 
contributes 

The word {\bf status} may be either : \\
EMPTY (or 0) - memory allocated, but no meaningfull information \\
NOISE (or 1) - noise component; no track information available \\
SHOWERING (or 2) - hit created as shower propagates; track information 
is not available \\
SINGLE\_TRACK (or 3) - energy deposition is due to a single track; typicaly 
created when showering is completed for a given particle \\
INTEGRATED (or 4) - energy  deposition may include contribution from more 
than 1 track;
typicaly obtained at the end of each event.

\subsection{Application Interface Routines and Methods}

\subsubsection{Application methods for C++ release}

\bigskip

   The header file is \$MCFSRC/showering/src/CalorInfo.hh

   The following methods can be invoked in a C++ version of {\bf usr\_analysis\_}
   routine or any other user C++ routine (since user routines are still called from
   fortran code, please do not forget to put the {\bf \_ } at the end). 

\newpage
\begin{center}
   {\bf static CalorInfo* getCalorInfo() } 
\end{center}
   - instanciates interface to calorimetry information (once per job !)
   
\begin{center}
   {\bf int numberOfCalorimeters() const }
\end{center}
   - returns number of calorimetrs in system 

\begin{center}
   {\bf const vector$<$const DenseMedium*$>$\& listOfCalorimeters() const }
\end{center}
   - returns vector of pointers to objects where minimum ionizing and showering processes
   happen and depostited energy is registered (i.e. calorimeters)
   
\begin{center}
   {\bf const int numberOfNeighbours(const DenseMedium* iCal) const}
\end{center}
   - returns number of neighbouring calorimeters for calorimeter iCal \\
   \\
   Example of usage : \\
   .......... \\
   \#include "CalorInfo.hh" \\
   .......... \\
   CalorInfo* info = CalorInfo::getCalorInfo() ; \\
   int nNeighbours ; \\
   vector$<$const DenseMedium*$>$::const\_iterator
  
      iter, iterEnd = info$\rightarrow$listOfCalorimeters.end() ; \\   
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(), iter!=iterEnd; iter++ ) \\
   \{ 

      nNeighbours = info$\rightarrow$numberOfNeighbours( *iter ) ; \\
   \} \\
   ......... \\
   
   
\begin{center}
   {\bf vector$<$DenseMedium*$>$\& listOfNeighbours(const DenseMedium* iCal) const}
\end{center}
   - returns a vector of pointers to objects where energy deposition through minimum 
   ionization and showering processes is recorded, located around 
   calorimeter iCal
   
\begin{center}
   {\bf int numberOfHits(const DenseMedium* iCal) const }
\end{center}
   - return number of hits in calorimeter iCal \\
   \\
   Example of usage : \\
   .......... \\
   \#include "CalorInfo.hh" \\
   .......... \\
   CalorInfo* info = CalorInfo::getCalorInfo() ; \\
   int nNeigh ; \\
   int nHits, nHitsInNeigh ;\\
   vector$<$const DenseMedium*$>$::const\_iterator

      iter, iterEnd = info$\rightarrow$listOfCalorimeters.end() ; \\  
   vector$<$DenseMedium*$>$::iterator iterNeigh, iterNeighEnd ;\\
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(), iter!=iterEnd; iter++ )\\
   \{ 

      nHits = info$\rightarrow$numberOfHits( *iter ) ; 

      if ( info$\rightarrow$listOfNeighbours( *iter ).empty() ) continue ; 

      iterNeighEnd = info$\rightarrow$listOfNeighbours( *iter ).end() ; 

      for ( iterNeigh=info$\rightarrow$listOfNeighbours( *iter ).begin() ; 

            iterNeigh!=iterNeighEnd; iterNeigh++ ) \\
      \{ 

         nHitsInNeigh = info$\rightarrow$numberOfHits( *iterNeigh ) ;\\
      \} \\
   \} \\
   .........\\


\begin{center}   
   {\bf CalorSignalMC*** pGridOfCells(const DenseMedium* iCal) const }
\end{center}
   - returns a 2-dimensional array of pointers to hits (objects of type CalorSignalMC; see 
   description below) in calorimeter iCal; some of them are real hits 
   (non-zero energy deposition), others are empty hits (zero energy deposition).\\
   \\
   Example of usage :\\
   .......... \\
   \#include "CalorInfo.hh" \\
   .......... \\
   CalorInfo* info = CalorInfo::getCalorInfo() ; \\
   CalorSignalMC** pGrid ;\\
   vector$<$const DenseMedium*$>$::const\_iterator

      iter, iterEnd = info$\rightarrow$listOfCalorimeters().end() ;\\
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(); iter!=iterEnd; iter++ )\\
   \{ 

      pGrid = info$\rightarrow$pGridOfCells( *iter ) ;\\
   \} \\
   
\begin{center}
   {\bf const char* segmentationType(const DenseMedium* iCal) const }
\end{center}
   - returns segmenation type of calorimeter iCal, either "Eta-Phi", or "Z-Phi", or "R-Phi" or "X-Y"; \\
   the system does NOT maintain other segmenation types
   
   NOTE : $z$-$\phi$ and $r$-$\phi$ segmentation type is specific to c++ subpackage of mcfast, version 4.1.2 and above.


\begin{center}
   {\bf const int* numberOfCells(const DenseMedium* iCal) const }  
\end{center}
   - returns number of cells, either in $\eta$-$\phi$, or $z$-$\phi$, or $r$-$\phi$, or $x$-$y$ units, depends 
   on segmentation type, for calorimeter iCal \\
   \\
   Example of usage : \\
   .......... \\
   \#include "CalorInfo.hh" \\
   .......... \\
   CalorInfo* info = CalorInfo::getCalorInfo() ;\\
   int nCells[2] ;\\
   vector$<$const DenseMedium*$>$::const\_iterator
 
      iter, iterEnd = info$\rightarrow$listOfCalorimeters.end() ; \\  
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(), iter!=iterEnd; iter++ )\\
   \{ 

      nCells[0] = info$\rightarrow$numberOfCells( *iter )[0] ;

      nCells[1] = info$\rightarrow$numberOfCells( *iter )[1] ;\\
   \} \\
   .........\\
   
\begin{center}
   {\bf const double* cellSize(const DenseMedium* iCal) const }
\end{center}
   - returns cell size either in $\eta$-$\phi$, or $z$-$\phi$, or $r$-$\phi$ or $x$-$y$ units, 
   depends on segmentaion type, for calorimeter iCal \\
   \\
   Example of usage : \\
   .......... \\
   \#include "CalorInfo.hh" \\
   .......... \\
   CalorInfo* info = CalorInfo::getCalorInfo() ; \\
   double cellSize[2] ; \\
   vector$<$const DenseMedium*$>$::const\_iterator 
   
      iter, iterEnd = info$\rightarrow$listOfCalorimeters.end() ; \\   
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(), iter!=iterEnd; iter++ ) \\
   \{ 

      const double* cell = info$\rightarrow$cellSize( *iter ) ; 

      cellSize[0] = *cell ; 

      cellSize[1] = *(cell+1) ; \\
   \} \\
   .........
   
\begin{center}
   {\bf const double stochasticTermEM(const DenseMedium* iCal) const }
\end{center}
   - returns stochastic term in the electromagnetic
   resolution of calorimeter iCal 

\begin{center}
   {\bf const double constantTermEM(const DenseMedium* iCal) const }
\end{center}
   - returns constant term in the electromagnetic
   resolution of calorimeter iCal 

\begin{center}
   {\bf const double stochasticTermHAD(const DenseMedium* iCal) const }
\end{center}
   - returns stochastic term in the hadronic
   resolution of calorimeter iCal 

\begin{center}
   {\bf const double constantTermHAD(const DenseMedium* iCal) const }
\end{center}
   - returns constant term in the hadronic
   resolution of calorimeter iCal 

\begin{center}
   {\bf const double ratioEMtoHAD(const DenseMedium* iCal) const }
\end{center}
   - returns $e$/$\pi$ ratio for calorimeter iCal 

\begin{center}
   {\bf const char* name(const DenseMedium* iCal) const }
\end{center}
   - returns name of calorimeter iCal as specified by user in geometry ASCII file
   
\begin{center}
   {\bf const double limits(const DenseMedium* iCal) const }
\end{center}
   -returns limits either in $\eta$-$\phi$, or $z$-$\phi$, or $r$-$\phi$, or $x$-$y$ units,
    depends on segmentation type, for calorimeter iCal. For example, if segmentation type
    is "Eta-Phi" limits[0] is $\eta_{min}$, limits[1] is $\eta_{max}$, limits[2] is $\phi_{min}$,
    and limits[3] is $\phi_{max}$


\begin{center}   
   {\bf const double etaMin(const DenseMedium* iCal) const }
\end{center}
   - returns $\eta_{min}$ for calorimeter iCal, if segmentation type is "Eta-Phi";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[0]}
   (see above). 

\begin{center}
   {\bf const double etaMax(const DenseMedium* iCal) const }
\end{center}
   - returns $\eta_{max}$ for calorimeter iCal, if segmentation type is "Eta-Phi";
   otherwise retuns FLT\_MAX. This method duplicates {\bf limits(iCal)[1]}
   (see above).

\begin{center}   
   {\bf const double phiMin(const DenseMedium* iCal) const }
\end{center}
   - returns $\phi_{min}$ for calorimeter iCal, if segmentation type is "Eta-Phi",
   or "Z-Phi", or "R-Phi";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[2]}
   (see above). 

\begin{center}
   {\bf const double etaMax(const DenseMedium* iCal) const }
\end{center}
   - returns $\eta_{max}$ for calorimeter iCal, if segmentation type is "Eta-Phi",
   or "Z-Phi", or "R-Phi";
   otherwise retuns FLT\_MAX. This method duplicates {\bf limits(iCal)[3]}
   (see above).
   
\begin{center}   
   {\bf const double rmin(const DenseMedium* iCal) const }
\end{center}
   - returns rmin for calorimeter iCal if segmentation type is "R-Phi";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[0]}
   (see above).

\begin{center}
   {\bf const double rmax(const DenseMedium* iCal) const }
\end{center}
   - returns rmax for calorimeter iCal if segmentation type is "R-Phi";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[1]}
   (see above).

\begin{center}
   {\bf const double zmin(const DenseMedium* iCal) const }
\end{center}
   - returns zmin for calorimeter iCal.

\begin{center}
   {\bf const double zmax(const DenseMedium* iCal) const }
\end{center}
   - returns zmax for calorimeter iCal. 

\begin{center}
   {\bf const double xmin(const DenseMedium* iCal) const }
\end{center}
   - returns xmin for calorimeter iCal if segmentation type is "X-Y";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[0]}
   (see above).

\begin{center}
   {\bf const double xmax(const DenseMedium* iCal) const }
\end{center}
   - returns xmax for calorimeter iCal if segmentation type is "X-Y";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[1]}
   (see above).

\newpage
\begin{center}
   {\bf const double ymin(const DenseMedium* iCal) const }
\end{center}
   - returns zmin for calorimeter iCal if segmentation type is "X-Y";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[2]}
   (see above).

\begin{center}
   {\bf const double ymax(const DenseMedium* iCal) const }
\end{center}
   - returns ymax for calorimeter iCal if segmentation type is "X-Y";
   otherwise returns FLT\_MAX. This method duplicates {\bf limits(iCal)[3]}
   (see above).


\bigskip

\bigskip

   There are also two methods that may be useful for the need of clusterization
   
   
\begin{center}
   {\bf vector$<$CalorCellAddress$>$ listOfHits(const DenseMedium* iCal) const }
\end{center}
   - fills up and returns vector of addresses (2-dimensional, either $\eta$-$\phi$
   or $x$-$y$) of cells with non-zero energy deposition 

\begin{center}
   {\bf vector$<$CalorCellAddress$>$ \\
   listOfHitsBySortedEnergy(const DenseMedium* iCal) const }
\end{center}
   - fills up and returns vector of addresses (2-dimensional, either $\eta$-$\phi$
   or $x$-$y$) of cells with non-zero energy deposition so that address of cell
   with maximum energy deposition occupies the first position in the vector
   and cell with minimum energy deposition is at the end of vector. \\
   \\
   Here, structure CalorCellAddress is defined in CalorCellAddress.hh file and is 
   represented by public data member int address[2], where address[0] is either $\eta$-, 
   or $x$-, or $z$-, or $r-$-index of cell and address[1] is either $\phi$- or $y$-index of cell.
   The header file can be found in \$MCFSRC/calorimetry/src area.

   However, user should be careful with using these two methods and keep number
   of calls to a minimum since each time a method is called a vector is created 
   which is inefficient.\\
   \\ 
   Example of recommended usage :\\
   ..........\\
   CalorInfo* info = CalorInfo::getCalorInfo() ;\\
   int nCells[2] ;\\
   vector$<$const DenseMedium*$>$::const\_iterator 

      iter, iterEnd = info$\rightarrow$listOfCalorimeters.end() ; \\  
   vector$<$CalorCellAddress$>$ HitList ; \\
   CalorSignalMC*** pGrid ; \\
   double eHit, eTotal ; \\
   int iHit, nHits ; \\
   int address[2] ; \\
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(), iter!=iterEnd; iter++ ) \\
   \{ \\
      HitList = info$\rightarrow$listOfHits( *iter ) ; \\
      if ( HitList.empty() ) continue ; \\
      eTotal = 0 ; \\
      nHits = HitList.size() ; \\
      pGrid = info$\rightarrow$pGridOfCells( *iter ) ; \\
      for ( iHit=0; iHit$<$nHits; iHit++ ) \\
      \{ \\
         address[0] = HitList[iHit].address[0] ; \\
	 address[1] = HitList[iHit].address[1] ; \\
	 eHit = pGrid[address[0]][address[1]]$\rightarrow$getE() ; \\ 
	 eTotal += eHit ;  \\ 
      \} \\
   \} \\
   ......... \\
   \\
   Example of {\bf NOT} recommended usage : \\
   .......... \\
   CalorInfo* info = CalorInfo::getCalorInfo() ; \\
   int nCells[2] ; \\
   vector$<$const DenseMedium*$>$::const\_iterator 
   
      iter, iterEnd = info$\rightarrow$listOfCalorimeters.end() ;\\   
   CalorSignalMC*** pGrid ;\\
   double eHit, eTotal ;\\
   int iHit, nHits ;\\
   int address[2] ; \\
   for ( iter=info$\rightarrow$listOfCalorimeters().begin(), iter!=iterEnd; iter++ ) \\
   \{ \\
      if ( info$\rightarrow$listOfHits( *iter ).empty() ) continue ; \\
      eTotal = 0 ; \\
      nHits = info$\rightarrow$listOfHits( *iter ).size() ; \\
      for ( iHit=0; iHit$<$nHits; iHit++ ) \\
      \{ \\
         address[0] = info$\rightarrow$listOfHits( *iter )[iHit].address[0] ; \\
	 address[1] = info$\rightarrow$listOfHits( *iter )[iHit].address[1] ; \\
	 eHit = pGrid[address[0]][address[1]]$\rightarrow$getE() ; \\
	 eTotal += eHit ;   \\
      \} \\
   \} \\
   ......... \\
   \\
Note : User may iterate instead of addressing elements of HitList by index. 

   Bedides, similar methods are supplied to address calorimeters and their
   neighbours (if any) by index (as in array) instead of iterator. Methods
   to get information on a given calorimeter by supplying its index in the
   vector have the same names as described above. Methods that have 
   "ForNeighbour" in their names are meant for getting information on
   neighbours iNeigh of a given calorimeter iCal, where iCal and iNeigh are
   integer indeces. 

\newpage
\subsubsection{Application routines for FORTRAN77 release}

\bigskip

\begin{center}
{CALOR\_INIT}
\end{center}

This routine initialize calorimetry hits if calorimeters are defined for the
MCFAST job.  In principle, this routine should not be called by the user since 
MCFAST takes care of the initialisation of public data structure. However,
it is documented in case the user wishes - at his/her own risk - to reinitialize
the event for some reason (same comment applies to the next 5 routines).

NOTE : Call to this routine turns off automatically if user selects integrated tracing \\
(i.e. C++ release) by using {\bf trace\_integrated TRUE} in the command file. 

Calling arguments : none

Language : FORTRAN77.

The routine is currently called at the stage of MCFAST initialization, 
by the MAIN\_FORTRAN routine, after the geometry is read in.

\bigskip

\begin{center}
{INIT\_ALL\_CAL\_HITS(NCAL)}
\end{center}

Initialisation of the heap space to store hit information. 

Calling arguments : 
\begin{itemize}
\item {Input NCAL is the number of calorimeters defined for the job.
Type - INTEGER}.
\end{itemize}

Language : C.

The routine is currently called by CALOR\_INIT routine.

NOTE : actualy, CALOR\_INIT duplicates INIT\_ALL\_CAL\_HITS; the reason 
of implementing CALOR\_INIT is not to put the whole calorimetry geometry data 
structure in MAIN\_FORTRAN.

\bigskip

\begin{center}
{EMCAL\_CLEAR\_HITS}
\end{center}

This routine loops over all calorimeters (if any) defined for the MCFAST job and 
clears out hits is each calorimeter on the event-by-event basis.

Calling arguments : none.

Language : FORTRAN77.

The routine is currently called by MCP\_ANALYZE routine.

NOTE : Call to this routine turns off automatically if user selects integrated tracing 
(i.e. C++ release) by using {\bf trace\_integrated TRUE} in the command file. 

\newpage
\begin{center}
{INIT\_CAL\_HITS(ICAL)}
\end{center}

This routine destroys all previous hits in a given calorimeter and preallocates 
calorimetry hits for the current event.

Calling arguments :
\begin{itemize}
\item{Input ICAL is the calorimeter number to clear out hits in.
Type - INTEGER.}
\end{itemize}

Language : C.

The routine is called by EMCAL\_CLEAR\_HITS.

\bigskip

\begin{center}
CONSOLIDATE\_CAL\_HITS(ICAL)
\end{center}

This routine collects all the hits produced by one or more particle(s)/shower(s)
that may end up in the same cell, and builds the track information subarray,
at the end of each event.

Calling arguments :
\begin{itemize}
\item {Input ICAl is the number of calorimeter to handle hits in. Type - INTEGER.}
\end{itemize}

Language : C.

This routine is called by CALOR\_CONSOLIDATE.

\begin{center}
CALOR\_CONSOLIDATE
\end{center}

This routine loops over all calorimeters specified for the MCFAST job and
does the hit collection in each of them, as the event precessing is completed.

Calling arguments : none.

Language : FORTRAN77.

This routine is called by MCP\_ANALYZE.

NOTE1 : CALOR\_CONSOLIDATE duplicates in some sense CONSOLIDATE\_CAL\_HITS;
the reason of creation of CALOR\_CONSOLIDATE is not to include the whole
calorimetery geometry data structure in MCP\_ANALYZE.
NOTE2 : Call to this routine turns off automatically if user selects integrated tracing 
(i.e. C++ release) by using {\bf trace\_integrated TRUE} in the command file. 


\bigskip

{\bf The following functions and routines may be called by a user at any stage 
of analysis, for example, from USR\_ANALYSIS.}

\bigskip

\begin{center}
NUM\_CAL\_HIT(ICAL)
\end{center}

This function returns the number of hits in a given calorimeter. 

\newpage

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter to check the number of hits in. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE1 : As the function is written in C, the indexing starts from 0, not from 1.

NOTE2 : If called from a FORTRAN code, should look as NUM\_CAL\_HIT(\%VAL(ICAL)).

\bigskip

\begin{center}
INFO\_CAL\_HIT(ICAL,IHIT,ICR1,ICR2,EMIP,EEM,EHAD,NTRACK)
\end{center}

This routines provides information about a particular hit.

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter number the hit to look at
belongs to. Type - INTEGER.}
\item {Input IHIT is the number of hit to get information about. Type - INTEGER.}
\item {Output ICR1 is x- or $\phi$-cell number the hit belongs to. Type - INTEGER.}
\item {Output ICR2 is y- or $\eta$-cell number the hit belongs to. Type - INTEGER.}
\item {Output EMIP, EEM, EHAD are fraction of energy in a given hit
produced due to minimum ionizing, electromagnetic showers, or hadronic showers respectevely. 
Type - REAL.}
\item {Output NTRACK is the number of tracks that have
contributed to the hit. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE : ICR1 and ICR2 are set to -1 if invalid hit.

NOTE : Since the routine is written in C, it is necessary to remember that
indexing of calorimeters and hits starts from 0, not from 1.

NOTE : If called from FORTRAN code, should look as \\
INFO\_CAL\_HIT(\%VAL(ICAL),\%VAL(IHIT),ICR1,ICR2,EMIP,EEM,EHAD,NTRACK)

\bigskip

\begin{center}
NUM\_TRACKS\_CAL\_HIT(ICAL,ICR1,ICR2)
\end{center}

This function returns number of tracks that have contributed into a given cell (ICR1,ICR2)
in a given calorimeter ICAL. Returns 0 if ``empty'' cell.

Calling arguments :
\begin{itemize}
\item{ Input ICAL is the calorimeter number. Type - INTEGER.}
\item{ Input ICR1 and ICR2 are indeces (address) of a given cell. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE : If called from FORTRAN routine, indexing should start from 0 and \%VAL should
precede the input arguments. 


\bigskip
\begin{center}
INFO\_TRACK\_CAL\_HIT(ICAL,ICR1,ICR2,ITRACK,HEP,PERCENT\_E\_TOTAL)
\end{center}

This routine provides information on a given track ITRACK that have contributed
into a given cell (ICR1,ICR2) in a given calorimeter ICAL. 

Calling arguments:
\begin{itemize}
\item{ Input ICAL is the calorimeter number. Type - INTEGER.}
\item{ Input ICR1 and ICR2 are indeces (address) of a given cell. Type - INTEGER.}
\item{ INPUT ITRACK is the contributing track index (ranges from 0 to NTRACKS-1). 
Type - INTEGER. }
\item{ Output HEP is the track index in the HEP list. Type - INTEGER.}
\item{ Output PERCENT\_E\_TOTAL is the portion of total energy deposited in
the (ICR1,ICR2) cell by the particle HEP (or by shower initiated by the
particle HEP).}
\end{itemize}

Language : C.

NOTE : If called from FORTRAN routine, indexing should start from 0 and \%VAL should
precede the input arguments while output arguments should be passed without \%VAL. 

\bigskip

\begin{center}
E\_MIP\_CAL\_HIT(ICAL,ICR1,ICR2)
\end{center}
\begin{center}
E\_EM\_CAL\_HIT(ICAL,ICR1,ICR2)
\end{center}
\begin{center}
E\_HAD\_CAL\_HIT(ICAL,ICR1,ICR2)
\end{center}

The above routines return energy deposition via minimum ionization, electromagnetic showers,
and hadronic showers respectevely into a given cell (ICR1,ICR2) in a given calorimeter ICAL.

Calling arguments :
\begin{itemize}
\item{ Input ICAL is the calorimeter number. Type - INTEGER.}
\item{ Input ICR1 and ICR2 are indeces (address) of a given cell. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE : If called from FORTRAN routine, indexing should start from 0, and \%VAL should
precede the input arguments. 


\newpage
\begin{center}
ENERGY\_CAL\_HIT(ICAL,IHIT)
\end{center}

This function returns the total energy of a given hit in a given calorimeter
(or a sum of energy deposited via minimum ionizing, electromagnetic, and hadronic
processes).

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter number a given hit belongs to.
Type - INTEGER.}
\item {Input IHIT is the hit number to get information about.
Type - INTEGER.}
\end{itemize}

Language : C.

NOTE : If called from a FORTRAN routine, should look as \\
ENERGY\_CAL\_HIT(\%VAL(ICAL),\%VAL(IHIT)) with indexing on ICAL and IHIT starting
from 0, not from 1.


\begin{center} 
SUM\_ENERGY\_CAL\_HIT(ICAL,ICR1,ICR2)
\end{center}

This function returns the total energy deposited via minimum ionizing, electromagnetic,
and hadronic processes in a given cell for a given calorimeter.

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter number a given cell belongs to.
Type - INTEGER.}
\item {Input ICR1 and ICR2 are indeces of x(or $\phi$)-y(or $\eta$) cell to find energy 
deposition in. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE1 : If called from FORTRAN routine, should look as \\
SUM\_ENERGY\_CAL\_HIT(\%VAL(ICAL),\%VAL(ICR1),\%VAL(ICR2)) with indexing starting 
from 0, not from 1. 

NOTE2 : Variable names {\bf ICR1} and {\bf ICR2} are specific to version 2.6 and above;
in version 2.5.1 they appear as {\bf IPHI} and {\bf IETA}.

NOTE3: Please be advised that in the version 2.5.1 {\bf IETA} appears first in the list
of arguments, and {\bf IPHI} follows it - the "reverse" order of arguments ! Please pay
attention when you make a call to the routine and check which version you are using !

\bigskip

\begin{center}
SUM\_E\_TOT\_CAL\_HITS(ICAL,TRNUM)
\end{center}

This function returns the total energy deposited by a given track/shower in a given
calorimeter. If TRNUM = 0, all energy in a given calorimeter is summed up.

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter number. Type - INTEGER.} 
\item {Input TRNUM is the track number in the HEP list. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE : If called from FORTRAN routine, should look as \\
SUM\_E\_TOT\_CAL\_HITS(\%VAL(ICAL),\%VAL(TRNUM)) with indexing of ICAL starting from 0,
not from 1; TRNUM should be actual track index in the HEP list, as in FORTRAN.

\bigskip

\begin{center}
PRINT\_ALL\_CAL\_HITS(ICAL)
\end{center}

This routine prints full information about all hits in a given calorimeters.

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeters number. Type - INTEGER.}
\end{itemize}

Language : C.

NOTE : If called from FORTRAN routine, should look as \\
PRINT\_ALL\_CAL\_HITS(\%VAL(ICAL)) with indexing starting from 0, not from 1. 


\begin{center}
GET\_CETA\_CPHI(ICAL,IETA,IPHI,PHI,ETA)
\end{center}

This routine calculates coordinates of the given $\eta$-$\phi$ cell in $\eta$-$\phi$
units.

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter number a given cell belongs to. Type - INTEGER.}
\item {Input IETA, IPHI are indeces of the $\eta$-$\phi$ cell. Type - INTEGER.}
\item {Output ETA, PHI are coordinates of the cell center in $\eta$-$\phi$ units.
Type - REAL.}
\end{itemize}

Language : FORTRAN.

NOTE : User should remember that in our current scheme IETA corresponds coordinate \#2 
(just like Y).


\begin{center}
CALOR\_ENERGY(ICAL,ICR1,ICR2)
\end{center}

This function returns total energy deposition (due to minimum ionization, 
electromagnetic, and hadronic processes) in a given cell for a given calorimeter.

Calling arguments :
\begin{itemize}
\item {Input ICAL is the calorimeter number the given cell belongs to. Type - INTEGER.}
\item {Input ICR1, ICR2 are indeces of the x-(or $\phi$)-y-(or $\eta$) cell. Type - INTEGER.}
\end{itemize}

Language : FORTRAN.

\end{document}
