<HEAD>
<TITLE>Rules For Declaring Structures and Common Blocks</TITLE>
</HEAD>

<CENTER><H1>
   Rules For Declaring Structures and Common Blocks
</H1></CENTER>

<P>
<font size=+1>

This page contains some rules for declaring fortran common blocks
and for declaring structures, in any language.  The rules are important
for work in a mixed-language and multi-platform environment.
They are obeyed inside MCFAST ( well, we think that we have found
and fixed all of the violations ... ) and users are encouraged
to follow these rules in their own code.

<p>
<center><img src=http://www-btev.fnal.gov/bars/rain.bar.gif></center>
<P>

First, one must define an <font color=red> 8 byte boundary</font>: 
this is as an address which is divisible by 8 
without remainder.  In a real*8 array, the first element occupies
bytes 0 to 7, the second  bytes 8 to 15, and so on.
Similarly one can  define a <font color=red>4 byte boundary</font>.

<p>
<center><img src=http://www-btev.fnal.gov/bars/rain.bar.gif></center>
<P>

<h2> The rules are:</h2>
<OL>
<LI> In any common block or structure, all 8 byte variables must start
   at an 8 byte boundary, relative to the start of the common block
   or structure.

<LI> Similarly all 4 byte variables must start at a 4-byte boundary
   relative to the start of the structure or common.

<LI> If a structure contains any 4 byte variables, its total length
   must be divisible by 4 without remainder.

<LI>If a structure contains any 8 byte variables, its total length
   must be divisible by 8 without remainder.
</OL>
Rules 3 and 4 are present to ensure that all elments in arrays of 
structures will statisfy rules 1 and 2.
<P>
If structures are nested inside strucutres or common blocks,
then the rules reply recursively into the most deeply nested structure.
<P>
<a href="#reasoning"> The reasoning behind these rules </a>
is explained at the bottom of this document.

<P>
<center><img src=http://www-btev.fnal.gov/bars/rain.bar.gif></center>
<P>

Now for some examples.  Consider the variables:
<PRE>

      character*1  c
      character*36 string1
      character*40 string2
      integer*2   i
      integer     j
      real        a
      real*8      b

Bad:  common /test/ i, j   - Fails rule 1

      structure /test/     - Fails rules 1 and 3
         integer*2 i
         integer   j
      end structure

      structure /test/     - Fails rule 3
         integer   j
         integer*2 i
      end structure

      common /test/ c, b        - Fails rule 2
      common /test/ string1, b  - Fails rule 2
      common /test/ i, b        - Fails rule 2
      common /test/ j, b        - Fails rule 2
      common /test/ a, b        - Fails rule 2

      structure /test/          - Fails rules 2 and 4
         integer j
         real*8 b
      end structure

      structure /test/          - Fails rule 4
         real*8 b
         integer j
      end structure

      structure /test/          - Fails rule 2.
         integer j
         real*8  b
         real    a
      end structure

      structure /test/          - Fails rule 4
         real*8 b
         character*36 string1
      end structure

Good:
      integer i
      real*8  a
      common /test/ a, i

      structure /test/
          integer i
	  integer pad
          real*8  a
      endstructure

      structure /test/
          real*8  a
          integer i
	  integer pad
      endstructure

      structure /test/
          real*8  a
          real    b
	  real    pad
      endstructure

      structure /test/
         real*8 b
         character*40 string1
      end structure
</PRE>

<p>
<center><img src=http://www-btev.fnal.gov/bars/rain.bar.gif></center>
<P>
<center><h2>
<a name="reasoning"> Why We Need the Rules</a>
</h2>
</center>

<P>
<OL>
<LI>Some machines require, and other only prefer, that:
  <UL>
   <LI> All doubles (real*8) start at an address which is divisible by 8 
        without remainder.
   <LI> All 4 byte variables start at an address which is
        divisible by 4 without remainder.
   </UL>
<LI> Most machines only start common blocks, single structures and
   arrays of structures at 8 byte boundaries.
</OL>

Some machines will not compile things which fail these rules.  Other
machines will compile and run, but will execute slowly - these machines
may or may not print compile-time or run-time warning messages.
Some machines will do just fine if you ignore the rules.  Some machines
will automatically insert padding in order to ensure that the structures
and common blocks are compliant with the rules - they may or may not
tell you this.   The padding maybe inserted within a structure or 
at the end of a structure.  Padding at the end makes sense in an
array of structures.
<P>
The really subtle problem is that on a given machine, the fortran, c and
c++ compilers may each do different things!   Even worse, on a given
machine the fortran compiler of one vendor may do something differently
than the fortran compiler of another vendor.  
<P>
These sorts of things were getting us into trouble with 
offline_track_struct, which is 127 4-byte words long.
On Linux, Absoft Fortran automatically inserts a word of padding between array 
elements but gcc does not.  On OSF1 and IRIX, all of fortran, gcc and g++
behave the same; so we got away with this for a long time.
<p>
<center><img src=http://www-btev.fnal.gov/bars/rain.bar.gif></center>
<P>

<A HREF="http://www-pat.fnal.gov/mcfast/doc_index.html">
<IMG src=http://www-pat.fnal.gov/buttons/default.leftbutton.gif align=bottom alt="[back]"></A>
<A HREF="http://www.fnal.gov/faw/fermilab_at_work.html">
<IMG src=http://www-pat.fnal.gov/buttons/default.homebutton.gif align=bottom alt="[fermi at work]"></A>
<A HREF="http://www-pat.fnal.gov/simulation.html">
<IMG src=http://www-pat.fnal.gov/buttons/simulation.home.gif align=bottom alt="[simulation home]"></A>

<p>
<center><img src=http://www-btev.fnal.gov/bars/rain.bar.gif></center>
<P>
</font>
<ADDRESS>
Rob Kutschke
<A HREF="mailto:kutschke@fnal.gov">kutschke@fnal.gov</A>
</ADDRESS>
