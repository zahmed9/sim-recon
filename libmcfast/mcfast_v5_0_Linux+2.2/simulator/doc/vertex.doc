
            Calling vertex fitting routines from McFast
                                                                 10/24/94
                                                                 A. Boehnlein
                                                                 4/6/95 -update
Vertex fitting in v2.0

To use the fitting routines, the user fills the track_kine bank with
tracks (either from offline tracks or HEP tracks) and calls the fitting
routines.  The vertex fitting routines currently work in a solenoidal 
magnetic field or a field-free region.  


                   --  User callable routines --


Source exists in ~bphyslib/mcfast/v2.0/src/vertex .

Call on Run initialization:******************************************

ksub_init.F      -- initialization routine, call at initialization.

ksub_set_bfld.F  -- sets the bfield, pass in magnetic field, and a flag 
                    indicating if the magnetic field is in tesla (true) 
                    or kgauss (false)

example code for a detector with a single solenoid covering the vertex
region:

#include "bfield_struct.inc"
#include "solenoid.inc"
#include "track_kine.inc"
      record /bfield_struct/ bf

      call ksub_init()
      bf.bmag = sol_par(1).Bfield
      bf.bdir(1) = 0.
      bf.bdir(2) = 0.
      bf.bdir(3) = 1.
      bf.type = 4           
      call ksub_set_bfld(bf,.true.)           

example code for a detector with no magnetic field in the vertex region:

#include "bfield_struct.inc"
#include "track_kine.inc"
      record /bfield_struct/ bf

      call ksub_init()
      bf.bmag = 0.
      bf.bdir(1) = 0.
      bf.bdir(2) = 0.
      bf.bdir(3) = 1.
      bf.type = 0.           
      call ksub_set_bfld(bf,.true.)           

***************************************************************

Routines for adding tracks to the TRACK_KINE list


For each event be sure to zero out the trk_kine list, before adding
new tracks.  This is done by zeroing trk_num.


kfil_off_track.F -- routine for filling the track_kine bank from offline
                    tracks.  The user passes in the position of the 
                    desired particle in the offline_track list and 
                    a flag indicating whether to use the HEP particle
                    id (flag = 0) or use a hypothesis about the particle
                    id (e=1/mu=2/pi=3/K=4/p=5), and the position of that
                    track in the track_kine list is returned to the user.

Example call:

      trk_num = 0                             ! Clear the trk_kine list
      idtyp = 0                               ! Use STDHEP particle id
      do it = 1,trk_off_num  !add all particles from offline track list
         status = kfil_off_track(it,idtyp,ik) ! make call
         vntrk = vntrk + 1                    ! update counter
         vitrk(vntrk) = ik                    ! store position in list
      enddo

status will return non-zero on error. 

kfil_hep.F --       routine for filling the track_kine list from HEP
                    tracks.  The user passes in the position of the 
                    desired particle in the HEP track list and 
                    a flag indicating whether to use the HEP particle
                    id (flag = 0) or use a hypothesis about the particle
                    id (e=1/mu=2/pi=3/K=4/p=5), and the position of that
                    track in the track_kine list is returned to the user.
                    called as above, however remember that the HEP tracks
                    have no covariance matrix.

ksub_insert_w.F --  Routine for adding in w track format to the track_kine
                    list.  Used with KFIT_BUILD_VTX, for example, which
                    will build a particle in w track format from several
                    input tracks.  The user inputs the track in W format
                    the covariance matrix, particle type, type of position
                    information,  the origin of the track (2 for tracks
                    from kinematic fits) whether or not the mass is fixed, if 
                    the mass is to be set by the user, the value of the
                    mass if that is the case, the user defined class.  The
                    position in the track_kine back is returned to the user.
                    See track_kine_struct.inc for origin definitions:

C   Inserts a particle in the track_kine list.
C
C  w1        track parameters in W format (Px,Py,Pz,E,x,y,z)
C
C  cov     real array (read)
C            Covariance matrix of TRKW (assumed to be 7x7)
C
C  idtyp     Integer variable (read)
C            Particle type
C
C  pos_info      integer variable (read)
C            1  ==> position info can be used in fit
C            0 ==> position info cannot be used in fit
C  fixed_mass  integer (read)
C            1  ==> mass is fixed (fixed during track updates)
C            0 ==> mass is floating
C
C  origin   integer variable (read)
C            ===> particle origin, see track_kine_struct.inc for definitions
C
C  use_mass integer variable (read)
C            1==> use value of mass
C            0==> do not use value of mass
C
C  mass     real variable (read) 
C  class    Integer variable (read)
C            User defined ID number ()

example call:
      record /wtrack_struct/ track
      DFLOAT vtrack(7,7)
          ....
      status = ksub_insert_w(track,vtrack,id,1,0,2,0,0.,0,ik) 
                                

kvtx_3d  --         routine for doing the fitting.  The user supplies the
                    number of tracks and an array of track positions in 
                    the track_kine list for fitting.
                    The user also supplies the following flags, and an
                    array for the vertex and an array for the vertex covariance
                    matrix, and Chisq.
UPDATE: 
C          0 ==> do not update input track parameters (just calculate chisq)
C          1 ==> update input track parameters only
C          2 ==> update input track parameters & covariance matrices and
C                replace the original unconstrainted parameters by the
C                new ones. ****** This is a dangerous option. ******

C  LUSEZ   logical variable (read)
C          TRUE  ==> use the value of Z as the starting value
C          FALSE ==> compute the starting value with a straight line approx.

 
example call
      integer vntrk,vitrk(max_trk),update
      logical lusez
      DFLOAT Z(3), VZ(3,3), chisq
        ....

        ....
      update = 0
      lusez = .false.
      z(1) = 0.0
      z(2) = 0.0
      z(3) = 0.0
      call vzero(vz,3*3*FLOAT_WORD)
      status = kvtx_3d(vntrk,vitrk,update,lusez,z,vz,chisq)

Additional information about the fit is stored in the common kine_chi.inc

C  Contains info for least square fits
C
C  max_iter      Max number of iterations
C  max_del_chisq   Quit iterating when change in chisquare < CHDELF
C
C  nconf      # of constraints
C  ndegf      # of degrees of freedom
C  iterf      actual number of iterations used in fit
C  choldf     value of chisquare at last iteration
C  chif       final chisquare

kfit_build_vtx --  Builds a particle out of several particles using a 
                   vertex constraint.  The user supplies the number of tracks,
                   an array pointing to those tracks in the TRK_KINE list, an 
                   array specifying the position information of the track, 
                   whether or not to update the tracks, a z vertex position, 
                   covariance matrix for the vertex, a flag for deciding
                   whether or not to compute the covariance matrix for the new 
                   particle, and the track parameters, covariance matrix for 
                   the track and chisq is returned to the user.  The user 
                   also passes in the dimension of the covariance matrix, at 
                   least 7.

C  IVOPT     Integer array (read)
C            IVOPT(IL) = 0  => Track ITRK(IL) has no position info at all
C            IVOPT(IL) = 1  => Track ITRK(IL) is not used to determine vertex
C                              but is constrained to pass through vertex
C            IVOPT(IL) = 2  => Track ITRK(IL) is used to determine vertex
C
C
C  LCOVAR    logical variable (read)
C            TRUE  ==> compute PW covariance matrix
C            FALSE ==> do not compute PW covariance matrix
C
C *PW        real array (write)
C            Fitted particle in W format (Px,Py,Pz,E,X,Y,Z)
C
C *VP        real array (write)
C            Covariance matrix of PW
C
C  MVP       integer variable (read)
C            First dimension of VP (must be at least 7)

Example call:
              ...
      logical lcovar
      integer mvp,ivopt(2)       
      parameter (mvp = 7)
      DFLOAT vtrack(7,7)
      record /wtrack_struct/ track
              ....
      ivopt(1) = 2
      ivopt(2) = 2
      update = 1
      lcovar = .true.
      call vzero(vz,3*3*FLOAT_WORD)
      call vzero(vtrack,7*7*FLOAT_WORD)
      call vzero(track,WTRACK_WORD)
      call vzero(z,3*FLOAT_WORD)
      nbvert_good = 1
      if (nb_to_vertex.eq.2) then
         nbvert_good = kfit_build_vtx(nb_to_vertex,btrack_to_vertex,
     &                ivopt,update,z,vz,lcovar,chisq,track,vtrack,
     &                mvp)


