#!/usr/local/bin/perl
######################################################################## 
# mdep myfile.F       - create *.d dependency files
#
# Created Oct. 25, 1996 - Lynn Garren
# Modified Jan. 9, 1998 to put results of _OUTLIB_ search in a separate file
# Modified Jan. 14, 1998 to recursively search include files
#                        (code supplied by Mike Procario)
# Modified Nov. 30, 1999 prevent infinite looping
#
######################################################################## 

$nooutput = "false";
# describe command syntax if no arguments are given
if ( $ARGV[0] eq "" ) {
    print("mdep [opts] file\n");
    print("opts: \n");
    print("	-outfile <file>   set explicit output file name\n");
    print("	-flagfile <file>  set explicit flagfile file name\n");
    print("	-inc \"<incdirs>\"  list include directories to search\n");
    print("	-noop             print but do not execute commands\n");
    print(" \n");
    print("mdep - get a list of fortran dependencies\n");
    print(" \n");
    die "mdep: specify a file name\n";
}

# read command line arguments
$count = 0;
$i = 0;
while ( $i <= $#ARGV ) {
   if( $ARGV[$i] =~ /^-/ ) {
      $arg = $ARGV[$i];
      if( $arg eq "-outfile" ) {
         $i++;
         $depend = $ARGV[$i]; 
      } elsif ($arg eq "-flagfile" ) { 
         $i++;
         $flagfile = $ARGV[$i]; 
      } elsif ($arg eq "-inc" ) { 
         $i++;
         $incdirs = $ARGV[$i]; 
	 @inclist = split(/\s+/,$incdirs);  # Split on all whitespace MP
	 unshift(@inclist,"");
      } elsif ($arg eq "-noop" ) { 
         $nooutput = "true";
      } else {
         print(" undefined option $arg will be ignored\n");
      }
   } else {
      $infile = $ARGV[$i];
      ##print(" ----> processing $infile\n");
   }
   $i++;
}
##foreach $dir (@inclist) {
##    print "include directory: $dir\n";
##}

if ( !$infile ) { die "mdep: input file not specified\n"; }
if ( !$depend ) {
   $depend = $infile;
   $depend =~ s/\.F$/\.d/;
}
if ( $depend eq $infile ) { $depend = $depend."\.d"; }
if ( !$flagfile ) { $flagfile = "flags"; }
$ofile = $depend;
$ofile =~ s/\.d$/\.o/;
$ofileg = $depend;
$ofileg =~ s/\.d$/\_g\.o/;
##print(" ----> creating $depend\n");
#
#   A list of files (@names_try) is generated from the original file 
#    and all include statements that are found. 
#   An attempt is made to open each file in the list @names_try using
#    the list of include directories.  When it is successful that name
#    is moved to the list @names_find
#

push(@names_try,$infile);               # Put the filename on the stack

#
# find:    #include "file"
#          #define _flag_
#
$count = 0;
while ( $search_file=pop(@names_try) ) {
    ##print "Searching for file $search_file\n";
    foreach $incpath (@inclist) {
	if ($incpath eq "") {
	    $open_name = $search_file;
	} else {
	    $open_name = $incpath."/".$search_file;
	}
	##print " Trying $open_name\n";
	if( open( INFILE, $open_name ) ) {		# open if found
	    push(@names_find, $search_file);
	    ##print "Found $open_name (save as $search_file)\n";
#
#           Loop over all lines in the file looking for #include.
#            Strip off everything but the filename and add it to the list.
#            Go back and look up the include files and see if they have 
#            include files.
#
	    while($line = <INFILE> ) {
		if( $line =~ /^\#include\s+\"(\w+\.\w+)\"/ ) {	#include file requires extension
		    push(@names_try, $1);		# include file name
        	    $list[$count] = $1;
        	    $count++;
		} elsif( $line =~ /^\#define\s+_([a-zA-Z0-9]+)_/ ) {     #check for flag
		    ##print "adding $open_name to $flagfile\n";
		    $flag = $1;
		    if ($flag eq "OUTLIB" ) { &flagged_file; }
		}
	    }
	    close INFILE;
	    last;        # File has been found so we do not need to look in more directories  MP
	}
    }
}
#
# Remove any duplicates
#
$l = @names_find;
for ($i = 1; $i < $l; $i++ ) {
    for ($j = $i+1; $j <=$l; $j++ ) {
	if ($names_find[$j] eq $names_find[$i] ) {
	    splice(@names_find,$j,1); # Removes 1 element at $j and closes up 
	}
    }
}

#
# now write the dependency file
#
#   Zeroth element @names_find is the filename which is already done.
#   Print out all but last with a continuation
#
$l = @names_find;                           	# Length of @names_find
open( OUTFILE, ">$depend") || die "mdep: cannot open $depend \n";
print OUTFILE "$ofile: $infile ";           	# file.o
for ($i = 1; $i < $l-1; $i++) {
    print OUTFILE " $names_find[$i]";
}
print OUTFILE " $names_find[$l-1]\n";		# last file name with continuation
print OUTFILE "$ofileg: $infile ";          	# file_g.o
for ($i = 1; $i < $l-1; $i++) {
    print OUTFILE " $names_find[$i]";
}
print OUTFILE " $names_find[$l-1]\n";		# last file name with continuation
close OUTFILE;

sub flagged_file {               	#add this file to the list for mcfast_out
    if( -e $flagfile ) {		# append to existing file
        open( FLGFILE, ">>$flagfile") || die "mdep: cannot open $flagfile \n";
    } else {				# open a new file
        open( FLGFILE, ">$flagfile") || die "mdep: cannot create $flagfile \n";
    }
    print FLGFILE "$open_name\n";     	#print file name 
    close FLGFILE;
}
