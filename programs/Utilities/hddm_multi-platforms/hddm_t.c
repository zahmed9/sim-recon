/*
 * hddm_t.c - DO NOT EDIT THIS FILE
 *
 * This file was generated automatically from the file ex1.xml by hddm-c.
 * This c file contains the i/o interface to the c structures described
 * in the data model (from ex1.xml).  Any program that needs access to the
 * data described in the model can compile this c source file, and make use
 * of the input/output services provided.
 *
 * The hddm data model tool set was written by
 * Richard Jones, University of Connecticut.
 *
 * For more information see the following web site
 *
 * http://zeus.phys.uconn.edu/halld/datamodel/doc
 */

#include "hddm_t.h"

t_Hits_t* make_t_Hits(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(t_Hits_t) + rep * sizeof(t_Hit_t);
   t_Hits_t* p = malloc(size);
   memset(p,0,size);
   return p;
}

t_Sides_t* make_t_Sides(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(t_Sides_t) + rep * sizeof(t_Side_t);
   t_Sides_t* p = malloc(size);
   memset(p,0,size);
   return p;
}

t_Slabs_t* make_t_Slabs(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(t_Slabs_t) + rep * sizeof(t_Slab_t);
   t_Slabs_t* p = malloc(size);
   memset(p,0,size);
   return p;
}

t_ForwardTOF_t* make_t_ForwardTOF()
{
   int size = sizeof(t_ForwardTOF_t);
   t_ForwardTOF_t* p = malloc(size);
   memset(p,0,size);
   return p;
}

t_HDDM_t* make_t_HDDM()
{
   int size = sizeof(t_HDDM_t);
   t_HDDM_t* p = malloc(size);
   memset(p,0,size);
   return p;
}

char HDDM_t_DocumentString[] = 
"<HDDM class=\"t\" version=\"1.0\">\n"
"  <forwardTOF>\n"
"    <slab y=\"float\" repeat=\"*\">\n"
"      <side end=\"int\" repeat=\"*\">\n"
"        <hit t=\"float\" dE=\"float\" repeat=\"*\" />\n"
"      </side>\n"
"    </slab>\n"
"  </forwardTOF>\n"
"</HDDM>\n";

int* sp;
int* dp;

static t_Hits_t* unpack_t_Hits()
{
   int size = *(sp++);
   int rep = *(sp++);
   t_Hits_t* his = 0;
   if (size > 0)
   {
      int r;
      his = make_t_Hits(rep);
      his->mult = rep;
      for (r = 0; r < rep; r++ )
      {
         dp = (int*) his;
         *(dp++) = *(sp++);
         *(dp++) = *(sp++);
      }
   }
   return his;
}

static t_Sides_t* unpack_t_Sides()
{
   int size = *(sp++);
   int rep = *(sp++);
   t_Sides_t* his = 0;
   if (size > 0)
   {
      int r;
      his = make_t_Sides(rep);
      his->mult = rep;
      for (r = 0; r < rep; r++ )
      {
         dp = (int*) his;
         *(dp++) = *(sp++);
      }
   }
   return his;
}

static t_Slabs_t* unpack_t_Slabs()
{
   int size = *(sp++);
   int rep = *(sp++);
   t_Slabs_t* his = 0;
   if (size > 0)
   {
      int r;
      his = make_t_Slabs(rep);
      his->mult = rep;
      for (r = 0; r < rep; r++ )
      {
         dp = (int*) his;
         *(dp++) = *(sp++);
      }
   }
   return his;
}

static t_ForwardTOF_t* unpack_t_ForwardTOF()
{
   int size = *(sp++);
   t_ForwardTOF_t* his = 0;
   if (size > 0)
   {
      his = make_t_ForwardTOF();
      {
         dp = (int*) his;
      }
   }
   return his;
}

static t_HDDM_t* unpack_t_HDDM()
{
   int size = *(sp++);
   t_HDDM_t* his = 0;
   if (size > 0)
   {
      his = make_t_HDDM();
      {
         dp = (int*) his;
      }
   }
   return his;
}

void* unpack_NULL()
{
   int size = *(sp++);
   sp += size;
   return 0;
}

t_HDDM_t* read_t_HDDM(t_iostream* fp)
{
   t_HDDM_t* this = 0;
   int ret = 0;
   int* buff = malloc(1000000);
   sp = buff;

   if (fp && (fp->iomode == HDDM_STREAM_INPUT))
   {
      ret = fread(buff,sizeof(int),1,fp->fd);
   }
   if (ret)
   {
      ret = *buff;
      ret -= fread(&sp[1],sizeof(int),ret,fp->fd);
   }
   else
   {
      free(buff);
      return 0;
   }
   if (ret == 0)
   {
      int s;
      void* ptrStack[10000];
      void* (*unpacker)() = fp->unpacker[0];
      ptrStack[0] = (*unpacker)();
      for (s = 1; s < fp->sections; s++)
      {
         int ptrOffset = fp->ptrOffset[s];
         int level = fp->modelLevel[s];
         int* ptr = ptrStack[level - 1];
         if (ptr != 0)
         {
            void** pp = (void**) &ptr[ptrOffset];
            unpacker = fp->unpacker[s];
            ptrStack[level] = (*unpacker)();
            *pp = ptrStack[level];
         }
         else
         {
            ptrStack[level] = 0;
         }
      }
   }
   free(buff);
   return this;
}

static int pack_t_Hits(t_Hits_t* pp, t_iostream* fp)
{
   int* dpp = dp++;
   int* spp = (int*) pp;
   int* dpm = dp++;
   if (spp != 0)
   {
      int n;
      *dpm = *(spp++);
      for (n = 0; n < *dpm; n++ )
      {
         *(dp++) = *(spp++);
         *(dp++) = *(spp++);
      }
      free(pp);
   }
   *dpp = dp - dpp - 1;
   return *dpp;
}

static int pack_t_Sides(t_Sides_t* pp, t_iostream* fp)
{
   int* dpp = dp++;
   int* spp = (int*) pp;
   int* dpm = dp++;
   if (spp != 0)
   {
      int n;
      *dpm = *(spp++);
      for (n = 0; n < *dpm; n++ )
      {
         *(dp++) = *(spp++);
         pack_t_Hits(*(t_Hits_t**) spp++, fp);
      }
      free(pp);
   }
   *dpp = dp - dpp - 1;
   return *dpp;
}

static int pack_t_Slabs(t_Slabs_t* pp, t_iostream* fp)
{
   int* dpp = dp++;
   int* spp = (int*) pp;
   int* dpm = dp++;
   if (spp != 0)
   {
      int n;
      *dpm = *(spp++);
      for (n = 0; n < *dpm; n++ )
      {
         *(dp++) = *(spp++);
         pack_t_Sides(*(t_Sides_t**) spp++, fp);
      }
      free(pp);
   }
   *dpp = dp - dpp - 1;
   return *dpp;
}

static int pack_t_ForwardTOF(t_ForwardTOF_t* pp, t_iostream* fp)
{
   int* dpp = dp++;
   int* spp = (int*) pp;
   if (spp != 0)
   {
      {
         pack_t_Slabs(*(t_Slabs_t**) spp++, fp);
      }
      free(pp);
   }
   *dpp = dp - dpp - 1;
   return *dpp;
}

static int pack_t_HDDM(t_HDDM_t* pp, t_iostream* fp)
{
   int* dpp = dp++;
   int* spp = (int*) pp;
   if (spp != 0)
   {
      {
         pack_t_ForwardTOF(*(t_ForwardTOF_t**) spp++, fp);
      }
      free(pp);
   }
   *dpp = dp - dpp - 1;
   return *dpp;
}

int flush_t_HDDM(t_HDDM_t* p,t_iostream* fp)
{
   int ret = 0;
   int* buff = malloc(1000000);
   dp = buff;
   sp = (int*) p;

   if (p != 0)
   {
      pack_t_HDDM((t_HDDM_t*) (sp++), fp);
   }
   if (fp && (fp->iomode == HDDM_STREAM_OUTPUT))
   {
      ret = fwrite(buff,sizeof(int),*buff+1,fp->fd);
   }
   free(buff);
   return ret;
}

static int getTag(char* d, char* tag)
{
   int level;
   char line[500];
   strncpy(line,d,500);
   line[499] = 0;
   level = strlen(strtok(line,"<"));
   strncpy(tag,strtok(NULL," >"),500);
   return level/2;
}

static char* getEndTag(char* d, char* tag)
{
   char line[500];
   char endTag[510];
   strncpy(line,d,500);
   line[499] = 0;
   if (strstr(strtok(line,"\n"),"/>") == 0)
   {
      sprintf(endTag,"</%s>",tag);
   }
   else
   {
      strcpy(endTag,"/>");
   }
   return strstr(d,endTag);
}

static int matches(char* d, char* c, t_iostream* fp)
{
   char ctag[500];
   char dtag[500];
   int clevel, dlevel;
   dlevel = getTag(d,dtag);
   while ((clevel = getTag(c,ctag)) == dlevel)
   {
      int ptrSeqNo = 0;
      if ((clevel == dlevel) && (strcmp(ctag,dtag) == 0))
      {
         int len = index(c+1,'\n') - c;
         if (strncmp(c,d,len) != 0)
         {
            return -1;
         }
         fp->modelLevel[fp->sections] = dlevel;
         if (strcmp(dtag,"hit") == 0)
         {
            fp->unpacker[fp->sections] = (void*) unpack_t_Hits;
            fp->ptrOffset[fp->sections] = 2 + ptrSeqNo*sizeof(int*)/sizeof(int);
            ++fp->sections;
         }
         else if (strcmp(dtag,"side") == 0)
         {
            fp->unpacker[fp->sections] = (void*) unpack_t_Sides;
            fp->ptrOffset[fp->sections] = 1 + ptrSeqNo*sizeof(int*)/sizeof(int);
            ++fp->sections;
         }
         else if (strcmp(dtag,"slab") == 0)
         {
            fp->unpacker[fp->sections] = (void*) unpack_t_Slabs;
            fp->ptrOffset[fp->sections] = 1 + ptrSeqNo*sizeof(int*)/sizeof(int);
            ++fp->sections;
         }
         else if (strcmp(dtag,"forwardTOF") == 0)
         {
            fp->unpacker[fp->sections] = (void*) unpack_t_ForwardTOF;
            fp->ptrOffset[fp->sections] = 0 + ptrSeqNo*sizeof(int*)/sizeof(int);
            ++fp->sections;
         }
         else if (strcmp(dtag,"HDDM") == 0)
         {
            fp->unpacker[fp->sections] = (void*) unpack_t_HDDM;
            fp->ptrOffset[fp->sections] = 0 + ptrSeqNo*sizeof(int*)/sizeof(int);
            ++fp->sections;
         }
         else
         {
            return -1;
         }
         c = index(c+1,'\n');
         d = index(d+1,'\n');
         while (getTag(d,dtag) > dlevel)
         {
            if (matches(d,c,fp))
            {
               return -1;
            }
            else
            {
               d = getEndTag(d,dtag);
            }
            d = index(d+1,'\n');
         }
         return 0;
      }
      else
      {
         c = getEndTag(c,ctag);
         ++ptrSeqNo;
      }
      c = index(c+1,'\n');
   }
   fp->unpacker[fp->sections++] = unpack_NULL;
   return 0;
}

t_iostream* open_t_HDDM(char* filename)
{
   t_iostream* fp = malloc(sizeof(t_iostream));
   char* p;
   fp->fd = fopen(filename,"r");
   if (fp->fd == 0)
   {
      free(fp);
      return 0;
   }
   fp->iomode = HDDM_STREAM_INPUT;
   fp->hddm = malloc(1000000);
   p = fp->hddm;
   *p = 0;
   while (strcmp(p,"</HDDM>\n") != 0)
   {
      int len = strlen(fp->hddm);
      if (len < 990000)
      {
         p = fp->hddm + len;
         fgets(p,10000,fp->fd);
      }
      else
      {
         break;
      }
   }
   fp->sections = 0;
   if (matches(fp->hddm,HDDM_t_DocumentString,fp) != 0)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"input file data model ");
      fprintf(stderr,"does not match ");
      fprintf(stderr,"compiled code.\n");
      fprintf(stderr,"Please recompile.\n");
      exit(9);
   }
   fp->filename = malloc(strlen(filename) + 1);
   strcpy(fp->filename,filename);
   return fp;
}

t_iostream* init_t_HDDM(char* filename)
{
   int len;
   t_iostream* fp = malloc(sizeof(t_iostream));
   fp->fd = fopen(filename,"w");
   if (fp->fd == 0)
   {
      free(fp);
      return 0;
   }
   fp->iomode = HDDM_STREAM_OUTPUT;
   len = strlen(HDDM_t_DocumentString);
   fp->hddm = malloc(len + 1);
   strcpy(fp->hddm,HDDM_t_DocumentString);
   if (fwrite(fp->hddm,1,len,fp->fd) != len)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"error writing to ");
      fprintf(stderr,"output file %s",filename);
      exit(9);
   }
   fp->filename = malloc(strlen(filename) + 1);
   strcpy(fp->filename,filename);
   return fp;
}

void close_t_HDDM(t_iostream* fp)
{
   fclose(fp->fd);
   free(fp->hddm);
   free(fp->filename);
   free(fp);
}
