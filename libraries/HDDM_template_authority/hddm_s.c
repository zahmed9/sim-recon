/*
 * hddm_s.c - DO NOT EDIT THIS FILE
 *
 * This file was generated automatically by hddm-c from the file
 * event.xml

 * This c file contains the i/o interface to the c structures
 * described in the data model (from event.xml). 
 *
 * The hddm data model tool set was written by
 * Richard Jones, University of Connecticut.
 *
 * For more information see the following web site
 *
 * http://zeus.phys.uconn.edu/halld/datamodel/doc
 */

int hddm_nullTarget=0;
#define HDDM_NULL (void*)&hddm_nullTarget

#include "hddm_s.h"


s_HDDM_t* make_s_HDDM()
{
   int size = sizeof(s_HDDM_t);
   s_HDDM_t* p = (s_HDDM_t*)MALLOC(size,"s_HDDM_t");
   p->physicsEvents = (s_PhysicsEvents_t*)&hddm_nullTarget;
   return p;
}

s_PhysicsEvents_t* make_s_PhysicsEvents(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_PhysicsEvents_t) + rep * sizeof(s_PhysicsEvent_t);
   s_PhysicsEvents_t* p = (s_PhysicsEvents_t*)MALLOC(size,"s_PhysicsEvents_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_PhysicsEvent_t* pp = &p->in[i];
      pp->eventNo = 0;
      pp->runNo = 0;
      pp->reactions = (s_Reactions_t*)&hddm_nullTarget;
      pp->hitView = (s_HitView_t*)&hddm_nullTarget;
   }
   return p;
}

s_Reactions_t* make_s_Reactions(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Reactions_t) + rep * sizeof(s_Reaction_t);
   s_Reactions_t* p = (s_Reactions_t*)MALLOC(size,"s_Reactions_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_Reaction_t* pp = &p->in[i];
      pp->type = 0;
      pp->weight = 0;
      pp->beam = (s_Beam_t*)&hddm_nullTarget;
      pp->target = (s_Target_t*)&hddm_nullTarget;
      pp->vertices = (s_Vertices_t*)&hddm_nullTarget;
   }
   return p;
}

s_Beam_t* make_s_Beam()
{
   int size = sizeof(s_Beam_t);
   s_Beam_t* p = (s_Beam_t*)MALLOC(size,"s_Beam_t");
   p->type = 0;
   p->momentum = (s_Momentum_t*)&hddm_nullTarget;
   p->properties = (s_Properties_t*)&hddm_nullTarget;
   return p;
}

s_Momentum_t* make_s_Momentum()
{
   int size = sizeof(s_Momentum_t);
   s_Momentum_t* p = (s_Momentum_t*)MALLOC(size,"s_Momentum_t");
   p->E = 0;
   p->px = 0;
   p->py = 0;
   p->pz = 0;
   return p;
}

s_Properties_t* make_s_Properties()
{
   int size = sizeof(s_Properties_t);
   s_Properties_t* p = (s_Properties_t*)MALLOC(size,"s_Properties_t");
   p->charge = 0;
   p->mass = 0;
   return p;
}

s_Target_t* make_s_Target()
{
   int size = sizeof(s_Target_t);
   s_Target_t* p = (s_Target_t*)MALLOC(size,"s_Target_t");
   p->type = 0;
   p->momentum = (s_Momentum_t*)&hddm_nullTarget;
   p->properties = (s_Properties_t*)&hddm_nullTarget;
   return p;
}

s_Vertices_t* make_s_Vertices(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Vertices_t) + rep * sizeof(s_Vertex_t);
   s_Vertices_t* p = (s_Vertices_t*)MALLOC(size,"s_Vertices_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_Vertex_t* pp = &p->in[i];
      pp->products = (s_Products_t*)&hddm_nullTarget;
      pp->origin = (s_Origin_t*)&hddm_nullTarget;
   }
   return p;
}

s_Products_t* make_s_Products(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Products_t) + rep * sizeof(s_Product_t);
   s_Products_t* p = (s_Products_t*)MALLOC(size,"s_Products_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_Product_t* pp = &p->in[i];
      pp->decayVertex = 0;
      pp->id = 0;
      pp->mech = 0;
      pp->parentid = 0;
      pp->pdgtype = 0;
      pp->type = 0;
      pp->momentum = (s_Momentum_t*)&hddm_nullTarget;
      pp->properties = (s_Properties_t*)&hddm_nullTarget;
   }
   return p;
}

s_Origin_t* make_s_Origin()
{
   int size = sizeof(s_Origin_t);
   s_Origin_t* p = (s_Origin_t*)MALLOC(size,"s_Origin_t");
   p->t = 0;
   p->vx = 0;
   p->vy = 0;
   p->vz = 0;
   return p;
}

s_HitView_t* make_s_HitView()
{
   int size = sizeof(s_HitView_t);
   s_HitView_t* p = (s_HitView_t*)MALLOC(size,"s_HitView_t");
   p->centralDC = (s_CentralDC_t*)&hddm_nullTarget;
   p->forwardDC = (s_ForwardDC_t*)&hddm_nullTarget;
   p->startCntr = (s_StartCntr_t*)&hddm_nullTarget;
   p->barrelEMcal = (s_BarrelEMcal_t*)&hddm_nullTarget;
   p->gapEMcal = (s_GapEMcal_t*)&hddm_nullTarget;
   p->Cerenkov = (s_Cerenkov_t*)&hddm_nullTarget;
   p->forwardTOF = (s_ForwardTOF_t*)&hddm_nullTarget;
   p->forwardEMcal = (s_ForwardEMcal_t*)&hddm_nullTarget;
   p->upstreamEMveto = (s_UpstreamEMveto_t*)&hddm_nullTarget;
   p->tagger = (s_Tagger_t*)&hddm_nullTarget;
   p->mcTrajectory = (s_McTrajectory_t*)&hddm_nullTarget;
   return p;
}

s_CentralDC_t* make_s_CentralDC()
{
   int size = sizeof(s_CentralDC_t);
   s_CentralDC_t* p = (s_CentralDC_t*)MALLOC(size,"s_CentralDC_t");
   p->cdcStraws = (s_CdcStraws_t*)&hddm_nullTarget;
   p->cdcTruthPoints = (s_CdcTruthPoints_t*)&hddm_nullTarget;
   return p;
}

s_CdcStraws_t* make_s_CdcStraws(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CdcStraws_t) + rep * sizeof(s_CdcStraw_t);
   s_CdcStraws_t* p = (s_CdcStraws_t*)MALLOC(size,"s_CdcStraws_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_CdcStraw_t* pp = &p->in[i];
      pp->ring = 0;
      pp->straw = 0;
      pp->cdcStrawHits = (s_CdcStrawHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_CdcStrawHits_t* make_s_CdcStrawHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CdcStrawHits_t) + rep * sizeof(s_CdcStrawHit_t);
   s_CdcStrawHits_t* p = (s_CdcStrawHits_t*)MALLOC(size,"s_CdcStrawHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_CdcStrawHit_t* pp = &p->in[i];
      pp->dE = 0;
      pp->t = 0;
   }
   return p;
}

s_CdcTruthPoints_t* make_s_CdcTruthPoints(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CdcTruthPoints_t) + rep * sizeof(s_CdcTruthPoint_t);
   s_CdcTruthPoints_t* p = (s_CdcTruthPoints_t*)MALLOC(size,"s_CdcTruthPoints_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_CdcTruthPoint_t* pp = &p->in[i];
      pp->dEdx = 0;
      pp->dradius = 0;
      pp->phi = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->r = 0;
      pp->t = 0;
      pp->track = 0;
      pp->z = 0;
   }
   return p;
}

s_ForwardDC_t* make_s_ForwardDC()
{
   int size = sizeof(s_ForwardDC_t);
   s_ForwardDC_t* p = (s_ForwardDC_t*)MALLOC(size,"s_ForwardDC_t");
   p->fdcChambers = (s_FdcChambers_t*)&hddm_nullTarget;
   return p;
}

s_FdcChambers_t* make_s_FdcChambers(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcChambers_t) + rep * sizeof(s_FdcChamber_t);
   s_FdcChambers_t* p = (s_FdcChambers_t*)MALLOC(size,"s_FdcChambers_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FdcChamber_t* pp = &p->in[i];
      pp->layer = 0;
      pp->module = 0;
      pp->fdcAnodeWires = (s_FdcAnodeWires_t*)&hddm_nullTarget;
      pp->fdcCathodeStrips = (s_FdcCathodeStrips_t*)&hddm_nullTarget;
      pp->fdcTruthPoints = (s_FdcTruthPoints_t*)&hddm_nullTarget;
   }
   return p;
}

s_FdcAnodeWires_t* make_s_FdcAnodeWires(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcAnodeWires_t) + rep * sizeof(s_FdcAnodeWire_t);
   s_FdcAnodeWires_t* p = (s_FdcAnodeWires_t*)MALLOC(size,"s_FdcAnodeWires_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FdcAnodeWire_t* pp = &p->in[i];
      pp->wire = 0;
      pp->fdcAnodeHits = (s_FdcAnodeHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_FdcAnodeHits_t* make_s_FdcAnodeHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcAnodeHits_t) + rep * sizeof(s_FdcAnodeHit_t);
   s_FdcAnodeHits_t* p = (s_FdcAnodeHits_t*)MALLOC(size,"s_FdcAnodeHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FdcAnodeHit_t* pp = &p->in[i];
      pp->dE = 0;
      pp->t = 0;
   }
   return p;
}

s_FdcCathodeStrips_t* make_s_FdcCathodeStrips(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcCathodeStrips_t) + rep * sizeof(s_FdcCathodeStrip_t);
   s_FdcCathodeStrips_t* p = (s_FdcCathodeStrips_t*)MALLOC(size,"s_FdcCathodeStrips_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FdcCathodeStrip_t* pp = &p->in[i];
      pp->plane = 0;
      pp->strip = 0;
      pp->fdcCathodeHits = (s_FdcCathodeHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_FdcCathodeHits_t* make_s_FdcCathodeHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcCathodeHits_t) + rep * sizeof(s_FdcCathodeHit_t);
   s_FdcCathodeHits_t* p = (s_FdcCathodeHits_t*)MALLOC(size,"s_FdcCathodeHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FdcCathodeHit_t* pp = &p->in[i];
      pp->q = 0;
      pp->t = 0;
   }
   return p;
}

s_FdcTruthPoints_t* make_s_FdcTruthPoints(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcTruthPoints_t) + rep * sizeof(s_FdcTruthPoint_t);
   s_FdcTruthPoints_t* p = (s_FdcTruthPoints_t*)MALLOC(size,"s_FdcTruthPoints_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FdcTruthPoint_t* pp = &p->in[i];
      pp->E = 0;
      pp->dEdx = 0;
      pp->dradius = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->track = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_StartCntr_t* make_s_StartCntr()
{
   int size = sizeof(s_StartCntr_t);
   s_StartCntr_t* p = (s_StartCntr_t*)MALLOC(size,"s_StartCntr_t");
   p->stcPaddles = (s_StcPaddles_t*)&hddm_nullTarget;
   p->stcTruthPoints = (s_StcTruthPoints_t*)&hddm_nullTarget;
   return p;
}

s_StcPaddles_t* make_s_StcPaddles(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_StcPaddles_t) + rep * sizeof(s_StcPaddle_t);
   s_StcPaddles_t* p = (s_StcPaddles_t*)MALLOC(size,"s_StcPaddles_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_StcPaddle_t* pp = &p->in[i];
      pp->sector = 0;
      pp->stcHits = (s_StcHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_StcHits_t* make_s_StcHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_StcHits_t) + rep * sizeof(s_StcHit_t);
   s_StcHits_t* p = (s_StcHits_t*)MALLOC(size,"s_StcHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_StcHit_t* pp = &p->in[i];
      pp->dE = 0;
      pp->t = 0;
   }
   return p;
}

s_StcTruthPoints_t* make_s_StcTruthPoints(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_StcTruthPoints_t) + rep * sizeof(s_StcTruthPoint_t);
   s_StcTruthPoints_t* p = (s_StcTruthPoints_t*)MALLOC(size,"s_StcTruthPoints_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_StcTruthPoint_t* pp = &p->in[i];
      pp->E = 0;
      pp->dEdx = 0;
      pp->phi = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->r = 0;
      pp->sector = 0;
      pp->t = 0;
      pp->track = 0;
      pp->z = 0;
   }
   return p;
}

s_BarrelEMcal_t* make_s_BarrelEMcal()
{
   int size = sizeof(s_BarrelEMcal_t);
   s_BarrelEMcal_t* p = (s_BarrelEMcal_t*)MALLOC(size,"s_BarrelEMcal_t");
   p->bcalCells = (s_BcalCells_t*)&hddm_nullTarget;
   p->bcalTruthShowers = (s_BcalTruthShowers_t*)&hddm_nullTarget;
   return p;
}

s_BcalCells_t* make_s_BcalCells(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_BcalCells_t) + rep * sizeof(s_BcalCell_t);
   s_BcalCells_t* p = (s_BcalCells_t*)MALLOC(size,"s_BcalCells_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_BcalCell_t* pp = &p->in[i];
      pp->layer = 0;
      pp->module = 0;
      pp->sector = 0;
      pp->bcalHits = (s_BcalHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_BcalHits_t* make_s_BcalHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_BcalHits_t) + rep * sizeof(s_BcalHit_t);
   s_BcalHits_t* p = (s_BcalHits_t*)MALLOC(size,"s_BcalHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_BcalHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->t = 0;
      pp->zLocal = 0;
   }
   return p;
}

s_BcalTruthShowers_t* make_s_BcalTruthShowers(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_BcalTruthShowers_t) + rep * sizeof(s_BcalTruthShower_t);
   s_BcalTruthShowers_t* p = (s_BcalTruthShowers_t*)MALLOC(size,"s_BcalTruthShowers_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_BcalTruthShower_t* pp = &p->in[i];
      pp->E = 0;
      pp->phi = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->r = 0;
      pp->t = 0;
      pp->track = 0;
      pp->z = 0;
   }
   return p;
}

s_GapEMcal_t* make_s_GapEMcal()
{
   int size = sizeof(s_GapEMcal_t);
   s_GapEMcal_t* p = (s_GapEMcal_t*)MALLOC(size,"s_GapEMcal_t");
   p->gcalCells = (s_GcalCells_t*)&hddm_nullTarget;
   p->gcalTruthShowers = (s_GcalTruthShowers_t*)&hddm_nullTarget;
   return p;
}

s_GcalCells_t* make_s_GcalCells(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_GcalCells_t) + rep * sizeof(s_GcalCell_t);
   s_GcalCells_t* p = (s_GcalCells_t*)MALLOC(size,"s_GcalCells_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_GcalCell_t* pp = &p->in[i];
      pp->module = 0;
      pp->gcalHits = (s_GcalHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_GcalHits_t* make_s_GcalHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_GcalHits_t) + rep * sizeof(s_GcalHit_t);
   s_GcalHits_t* p = (s_GcalHits_t*)MALLOC(size,"s_GcalHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_GcalHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->t = 0;
      pp->zLocal = 0;
   }
   return p;
}

s_GcalTruthShowers_t* make_s_GcalTruthShowers(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_GcalTruthShowers_t) + rep * sizeof(s_GcalTruthShower_t);
   s_GcalTruthShowers_t* p = (s_GcalTruthShowers_t*)MALLOC(size,"s_GcalTruthShowers_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_GcalTruthShower_t* pp = &p->in[i];
      pp->E = 0;
      pp->phi = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->r = 0;
      pp->t = 0;
      pp->track = 0;
      pp->z = 0;
   }
   return p;
}

s_Cerenkov_t* make_s_Cerenkov()
{
   int size = sizeof(s_Cerenkov_t);
   s_Cerenkov_t* p = (s_Cerenkov_t*)MALLOC(size,"s_Cerenkov_t");
   p->cereSections = (s_CereSections_t*)&hddm_nullTarget;
   p->cereTruthPoints = (s_CereTruthPoints_t*)&hddm_nullTarget;
   return p;
}

s_CereSections_t* make_s_CereSections(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CereSections_t) + rep * sizeof(s_CereSection_t);
   s_CereSections_t* p = (s_CereSections_t*)MALLOC(size,"s_CereSections_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_CereSection_t* pp = &p->in[i];
      pp->sector = 0;
      pp->cereHits = (s_CereHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_CereHits_t* make_s_CereHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CereHits_t) + rep * sizeof(s_CereHit_t);
   s_CereHits_t* p = (s_CereHits_t*)MALLOC(size,"s_CereHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_CereHit_t* pp = &p->in[i];
      pp->pe = 0;
      pp->t = 0;
   }
   return p;
}

s_CereTruthPoints_t* make_s_CereTruthPoints(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CereTruthPoints_t) + rep * sizeof(s_CereTruthPoint_t);
   s_CereTruthPoints_t* p = (s_CereTruthPoints_t*)MALLOC(size,"s_CereTruthPoints_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_CereTruthPoint_t* pp = &p->in[i];
      pp->E = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->track = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_ForwardTOF_t* make_s_ForwardTOF()
{
   int size = sizeof(s_ForwardTOF_t);
   s_ForwardTOF_t* p = (s_ForwardTOF_t*)MALLOC(size,"s_ForwardTOF_t");
   p->ftofCounters = (s_FtofCounters_t*)&hddm_nullTarget;
   p->ftofTruthPoints = (s_FtofTruthPoints_t*)&hddm_nullTarget;
   return p;
}

s_FtofCounters_t* make_s_FtofCounters(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FtofCounters_t) + rep * sizeof(s_FtofCounter_t);
   s_FtofCounters_t* p = (s_FtofCounters_t*)MALLOC(size,"s_FtofCounters_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FtofCounter_t* pp = &p->in[i];
      pp->bar = 0;
      pp->plane = 0;
      pp->ftofNorthHits = (s_FtofNorthHits_t*)&hddm_nullTarget;
      pp->ftofSouthHits = (s_FtofSouthHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_FtofNorthHits_t* make_s_FtofNorthHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FtofNorthHits_t) + rep * sizeof(s_FtofNorthHit_t);
   s_FtofNorthHits_t* p = (s_FtofNorthHits_t*)MALLOC(size,"s_FtofNorthHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FtofNorthHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->dE = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_FtofSouthHits_t* make_s_FtofSouthHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FtofSouthHits_t) + rep * sizeof(s_FtofSouthHit_t);
   s_FtofSouthHits_t* p = (s_FtofSouthHits_t*)MALLOC(size,"s_FtofSouthHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FtofSouthHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->dE = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_FtofTruthPoints_t* make_s_FtofTruthPoints(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FtofTruthPoints_t) + rep * sizeof(s_FtofTruthPoint_t);
   s_FtofTruthPoints_t* p = (s_FtofTruthPoints_t*)MALLOC(size,"s_FtofTruthPoints_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FtofTruthPoint_t* pp = &p->in[i];
      pp->E = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->track = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_ForwardEMcal_t* make_s_ForwardEMcal()
{
   int size = sizeof(s_ForwardEMcal_t);
   s_ForwardEMcal_t* p = (s_ForwardEMcal_t*)MALLOC(size,"s_ForwardEMcal_t");
   p->fcalBlocks = (s_FcalBlocks_t*)&hddm_nullTarget;
   p->fcalTruthShowers = (s_FcalTruthShowers_t*)&hddm_nullTarget;
   return p;
}

s_FcalBlocks_t* make_s_FcalBlocks(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FcalBlocks_t) + rep * sizeof(s_FcalBlock_t);
   s_FcalBlocks_t* p = (s_FcalBlocks_t*)MALLOC(size,"s_FcalBlocks_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FcalBlock_t* pp = &p->in[i];
      pp->column = 0;
      pp->row = 0;
      pp->fcalHits = (s_FcalHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_FcalHits_t* make_s_FcalHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FcalHits_t) + rep * sizeof(s_FcalHit_t);
   s_FcalHits_t* p = (s_FcalHits_t*)MALLOC(size,"s_FcalHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FcalHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->t = 0;
   }
   return p;
}

s_FcalTruthShowers_t* make_s_FcalTruthShowers(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FcalTruthShowers_t) + rep * sizeof(s_FcalTruthShower_t);
   s_FcalTruthShowers_t* p = (s_FcalTruthShowers_t*)MALLOC(size,"s_FcalTruthShowers_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_FcalTruthShower_t* pp = &p->in[i];
      pp->E = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->track = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_UpstreamEMveto_t* make_s_UpstreamEMveto()
{
   int size = sizeof(s_UpstreamEMveto_t);
   s_UpstreamEMveto_t* p = (s_UpstreamEMveto_t*)MALLOC(size,"s_UpstreamEMveto_t");
   p->upvPaddles = (s_UpvPaddles_t*)&hddm_nullTarget;
   p->upvTruthShowers = (s_UpvTruthShowers_t*)&hddm_nullTarget;
   return p;
}

s_UpvPaddles_t* make_s_UpvPaddles(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_UpvPaddles_t) + rep * sizeof(s_UpvPaddle_t);
   s_UpvPaddles_t* p = (s_UpvPaddles_t*)MALLOC(size,"s_UpvPaddles_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_UpvPaddle_t* pp = &p->in[i];
      pp->layer = 0;
      pp->row = 0;
      pp->upvLeftHits = (s_UpvLeftHits_t*)&hddm_nullTarget;
      pp->upvRightHits = (s_UpvRightHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_UpvLeftHits_t* make_s_UpvLeftHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_UpvLeftHits_t) + rep * sizeof(s_UpvLeftHit_t);
   s_UpvLeftHits_t* p = (s_UpvLeftHits_t*)MALLOC(size,"s_UpvLeftHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_UpvLeftHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->t = 0;
   }
   return p;
}

s_UpvRightHits_t* make_s_UpvRightHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_UpvRightHits_t) + rep * sizeof(s_UpvRightHit_t);
   s_UpvRightHits_t* p = (s_UpvRightHits_t*)MALLOC(size,"s_UpvRightHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_UpvRightHit_t* pp = &p->in[i];
      pp->E = 0;
      pp->t = 0;
   }
   return p;
}

s_UpvTruthShowers_t* make_s_UpvTruthShowers(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_UpvTruthShowers_t) + rep * sizeof(s_UpvTruthShower_t);
   s_UpvTruthShowers_t* p = (s_UpvTruthShowers_t*)MALLOC(size,"s_UpvTruthShowers_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_UpvTruthShower_t* pp = &p->in[i];
      pp->E = 0;
      pp->primary = 0;
      pp->ptype = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->t = 0;
      pp->track = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

s_Tagger_t* make_s_Tagger()
{
   int size = sizeof(s_Tagger_t);
   s_Tagger_t* p = (s_Tagger_t*)MALLOC(size,"s_Tagger_t");
   p->microChannels = (s_MicroChannels_t*)&hddm_nullTarget;
   return p;
}

s_MicroChannels_t* make_s_MicroChannels(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_MicroChannels_t) + rep * sizeof(s_MicroChannel_t);
   s_MicroChannels_t* p = (s_MicroChannels_t*)MALLOC(size,"s_MicroChannels_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_MicroChannel_t* pp = &p->in[i];
      pp->E = 0;
      pp->column = 0;
      pp->row = 0;
      pp->taggerHits = (s_TaggerHits_t*)&hddm_nullTarget;
   }
   return p;
}

s_TaggerHits_t* make_s_TaggerHits(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_TaggerHits_t) + rep * sizeof(s_TaggerHit_t);
   s_TaggerHits_t* p = (s_TaggerHits_t*)MALLOC(size,"s_TaggerHits_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_TaggerHit_t* pp = &p->in[i];
      pp->t = 0;
   }
   return p;
}

s_McTrajectory_t* make_s_McTrajectory()
{
   int size = sizeof(s_McTrajectory_t);
   s_McTrajectory_t* p = (s_McTrajectory_t*)MALLOC(size,"s_McTrajectory_t");
   p->mcTrajectoryPoints = (s_McTrajectoryPoints_t*)&hddm_nullTarget;
   return p;
}

s_McTrajectoryPoints_t* make_s_McTrajectoryPoints(int n)
{
   int i;
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_McTrajectoryPoints_t) + rep * sizeof(s_McTrajectoryPoint_t);
   s_McTrajectoryPoints_t* p = (s_McTrajectoryPoints_t*)MALLOC(size,"s_McTrajectoryPoints_t");
   p->mult = 0;
   for (i=0; i<n; i++) {
      s_McTrajectoryPoint_t* pp = &p->in[i];
      pp->E = 0;
      pp->dE = 0;
      pp->mech = 0;
      pp->part = 0;
      pp->primary_track = 0;
      pp->px = 0;
      pp->py = 0;
      pp->pz = 0;
      pp->radlen = 0;
      pp->step = 0;
      pp->t = 0;
      pp->track = 0;
      pp->x = 0;
      pp->y = 0;
      pp->z = 0;
   }
   return p;
}

char HDDM_s_DocumentString[] = 
"<HDDM class=\"s\" version=\"1.0\" xmlns=\"http://www.gluex.org/hddm\">\n"
"  <physicsEvent eventNo=\"int\" maxOccurs=\"unbounded\" runNo=\"int\">\n"
"    <reaction maxOccurs=\"unbounded\" minOccurs=\"0\" type=\"int\" weight=\"float\">\n"
"      <beam minOccurs=\"0\" type=\"Particle_t\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"      </beam>\n"
"      <target minOccurs=\"0\" type=\"Particle_t\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"      </target>\n"
"      <vertex maxOccurs=\"unbounded\">\n"
"        <product decayVertex=\"int\" id=\"int\" maxOccurs=\"unbounded\" mech=\"int\" parentid=\"int\" pdgtype=\"int\" type=\"Particle_t\">\n"
"          <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"          <properties charge=\"int\" mass=\"float\" />\n"
"        </product>\n"
"        <origin t=\"float\" vx=\"float\" vy=\"float\" vz=\"float\" />\n"
"      </vertex>\n"
"    </reaction>\n"
"    <hitView minOccurs=\"0\" version=\"2.0\">\n"
"      <centralDC minOccurs=\"0\">\n"
"        <cdcStraw maxOccurs=\"unbounded\" minOccurs=\"0\" ring=\"int\" straw=\"int\">\n"
"          <cdcStrawHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"        </cdcStraw>\n"
"        <cdcTruthPoint dEdx=\"float\" dradius=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\" />\n"
"      </centralDC>\n"
"      <forwardDC minOccurs=\"0\">\n"
"        <fdcChamber layer=\"int\" maxOccurs=\"unbounded\" module=\"int\">\n"
"          <fdcAnodeWire maxOccurs=\"unbounded\" minOccurs=\"0\" wire=\"int\">\n"
"            <fdcAnodeHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </fdcAnodeWire>\n"
"          <fdcCathodeStrip maxOccurs=\"unbounded\" minOccurs=\"0\" plane=\"int\" strip=\"int\">\n"
"            <fdcCathodeHit maxOccurs=\"unbounded\" q=\"float\" t=\"float\" />\n"
"          </fdcCathodeStrip>\n"
"          <fdcTruthPoint E=\"float\" dEdx=\"float\" dradius=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"        </fdcChamber>\n"
"      </forwardDC>\n"
"      <startCntr minOccurs=\"0\">\n"
"        <stcPaddle maxOccurs=\"unbounded\" minOccurs=\"0\" sector=\"int\">\n"
"          <stcHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"        </stcPaddle>\n"
"        <stcTruthPoint E=\"float\" dEdx=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" sector=\"int\" t=\"float\" track=\"int\" z=\"float\" />\n"
"      </startCntr>\n"
"      <barrelEMcal minOccurs=\"0\">\n"
"        <bcalCell layer=\"int\" maxOccurs=\"4\" minOccurs=\"0\" module=\"int\" sector=\"int\">\n"
"          <bcalHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" zLocal=\"float\" />\n"
"        </bcalCell>\n"
"        <bcalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\" />\n"
"      </barrelEMcal>\n"
"      <gapEMcal minOccurs=\"0\">\n"
"        <gcalCell maxOccurs=\"48\" minOccurs=\"0\" module=\"int\">\n"
"          <gcalHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" zLocal=\"float\" />\n"
"        </gcalCell>\n"
"        <gcalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\" />\n"
"      </gapEMcal>\n"
"      <Cerenkov minOccurs=\"0\">\n"
"        <cereSection maxOccurs=\"unbounded\" minOccurs=\"0\" sector=\"int\">\n"
"          <cereHit maxOccurs=\"unbounded\" pe=\"float\" t=\"float\" />\n"
"        </cereSection>\n"
"        <cereTruthPoint E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"      </Cerenkov>\n"
"      <forwardTOF minOccurs=\"0\">\n"
"        <ftofCounter bar=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" plane=\"int\">\n"
"          <ftofNorthHit E=\"float\" dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" x=\"float\" y=\"float\" z=\"float\" />\n"
"          <ftofSouthHit E=\"float\" dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" x=\"float\" y=\"float\" z=\"float\" />\n"
"        </ftofCounter>\n"
"        <ftofTruthPoint E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"      </forwardTOF>\n"
"      <forwardEMcal minOccurs=\"0\">\n"
"        <fcalBlock column=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <fcalHit E=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"        </fcalBlock>\n"
"        <fcalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"      </forwardEMcal>\n"
"      <upstreamEMveto minOccurs=\"0\">\n"
"        <upvPaddle layer=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <upvLeftHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"          <upvRightHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"        </upvPaddle>\n"
"        <upvTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"      </upstreamEMveto>\n"
"      <tagger minOccurs=\"0\">\n"
"        <microChannel E=\"float\" column=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <taggerHit maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"        </microChannel>\n"
"      </tagger>\n"
"      <mcTrajectory minOccurs=\"0\">\n"
"        <mcTrajectoryPoint E=\"float\" dE=\"float\" maxOccurs=\"unbounded\" mech=\"int\" minOccurs=\"0\" part=\"int\" primary_track=\"int\" px=\"float\" py=\"float\" pz=\"float\" radlen=\"float\" step=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"      </mcTrajectory>\n"
"    </hitView>\n"
"  </physicsEvent>\n"
"</HDDM>\n"
;


static s_HDDM_t* unpack_s_HDDM(XDR* xdrs, popNode* pop)
{
   s_HDDM_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_HDDM();
      {
         int p;
         void* (*ptr) = (void**) &this1->physicsEvents;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_PhysicsEvents_t* unpack_s_PhysicsEvents(XDR* xdrs, popNode* pop)
{
   s_PhysicsEvents_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_PhysicsEvents(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].reactions;
         xdr_int(xdrs,&this1->in[m].eventNo);
         xdr_int(xdrs,&this1->in[m].runNo);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Reactions_t* unpack_s_Reactions(XDR* xdrs, popNode* pop)
{
   s_Reactions_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Reactions(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].beam;
         xdr_int(xdrs,&this1->in[m].type);
         xdr_float(xdrs,&this1->in[m].weight);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Beam_t* unpack_s_Beam(XDR* xdrs, popNode* pop)
{
   s_Beam_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Beam();
      {
         int p;
         void* (*ptr) = (void**) &this1->momentum;
         xdr_int(xdrs,(int*)&this1->type);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Momentum_t* unpack_s_Momentum(XDR* xdrs, popNode* pop)
{
   s_Momentum_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Momentum();
      {
         xdr_float(xdrs,&this1->E);
         xdr_float(xdrs,&this1->px);
         xdr_float(xdrs,&this1->py);
         xdr_float(xdrs,&this1->pz);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Properties_t* unpack_s_Properties(XDR* xdrs, popNode* pop)
{
   s_Properties_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Properties();
      {
         xdr_int(xdrs,&this1->charge);
         xdr_float(xdrs,&this1->mass);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Target_t* unpack_s_Target(XDR* xdrs, popNode* pop)
{
   s_Target_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Target();
      {
         int p;
         void* (*ptr) = (void**) &this1->momentum;
         xdr_int(xdrs,(int*)&this1->type);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Vertices_t* unpack_s_Vertices(XDR* xdrs, popNode* pop)
{
   s_Vertices_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Vertices(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].products;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Products_t* unpack_s_Products(XDR* xdrs, popNode* pop)
{
   s_Products_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Products(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].momentum;
         xdr_int(xdrs,&this1->in[m].decayVertex);
         xdr_int(xdrs,&this1->in[m].id);
         xdr_int(xdrs,&this1->in[m].mech);
         xdr_int(xdrs,&this1->in[m].parentid);
         xdr_int(xdrs,&this1->in[m].pdgtype);
         xdr_int(xdrs,(int*)&this1->in[m].type);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Origin_t* unpack_s_Origin(XDR* xdrs, popNode* pop)
{
   s_Origin_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Origin();
      {
         xdr_float(xdrs,&this1->t);
         xdr_float(xdrs,&this1->vx);
         xdr_float(xdrs,&this1->vy);
         xdr_float(xdrs,&this1->vz);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_HitView_t* unpack_s_HitView(XDR* xdrs, popNode* pop)
{
   s_HitView_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_HitView();
      {
         int p;
         void* (*ptr) = (void**) &this1->centralDC;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CentralDC_t* unpack_s_CentralDC(XDR* xdrs, popNode* pop)
{
   s_CentralDC_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_CentralDC();
      {
         int p;
         void* (*ptr) = (void**) &this1->cdcStraws;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CdcStraws_t* unpack_s_CdcStraws(XDR* xdrs, popNode* pop)
{
   s_CdcStraws_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CdcStraws(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].cdcStrawHits;
         xdr_int(xdrs,&this1->in[m].ring);
         xdr_int(xdrs,&this1->in[m].straw);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CdcStrawHits_t* unpack_s_CdcStrawHits(XDR* xdrs, popNode* pop)
{
   s_CdcStrawHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CdcStrawHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CdcTruthPoints_t* unpack_s_CdcTruthPoints(XDR* xdrs, popNode* pop)
{
   s_CdcTruthPoints_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CdcTruthPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dEdx);
         xdr_float(xdrs,&this1->in[m].dradius);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].r);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardDC_t* unpack_s_ForwardDC(XDR* xdrs, popNode* pop)
{
   s_ForwardDC_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_ForwardDC();
      {
         int p;
         void* (*ptr) = (void**) &this1->fdcChambers;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcChambers_t* unpack_s_FdcChambers(XDR* xdrs, popNode* pop)
{
   s_FdcChambers_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcChambers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].fdcAnodeWires;
         xdr_int(xdrs,&this1->in[m].layer);
         xdr_int(xdrs,&this1->in[m].module);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcAnodeWires_t* unpack_s_FdcAnodeWires(XDR* xdrs, popNode* pop)
{
   s_FdcAnodeWires_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcAnodeWires(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].fdcAnodeHits;
         xdr_int(xdrs,&this1->in[m].wire);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcAnodeHits_t* unpack_s_FdcAnodeHits(XDR* xdrs, popNode* pop)
{
   s_FdcAnodeHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcAnodeHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcCathodeStrips_t* unpack_s_FdcCathodeStrips(XDR* xdrs, popNode* pop)
{
   s_FdcCathodeStrips_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcCathodeStrips(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].fdcCathodeHits;
         xdr_int(xdrs,&this1->in[m].plane);
         xdr_int(xdrs,&this1->in[m].strip);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcCathodeHits_t* unpack_s_FdcCathodeHits(XDR* xdrs, popNode* pop)
{
   s_FdcCathodeHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcCathodeHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].q);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcTruthPoints_t* unpack_s_FdcTruthPoints(XDR* xdrs, popNode* pop)
{
   s_FdcTruthPoints_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcTruthPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].dEdx);
         xdr_float(xdrs,&this1->in[m].dradius);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_StartCntr_t* unpack_s_StartCntr(XDR* xdrs, popNode* pop)
{
   s_StartCntr_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_StartCntr();
      {
         int p;
         void* (*ptr) = (void**) &this1->stcPaddles;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_StcPaddles_t* unpack_s_StcPaddles(XDR* xdrs, popNode* pop)
{
   s_StcPaddles_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_StcPaddles(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].stcHits;
         xdr_int(xdrs,&this1->in[m].sector);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_StcHits_t* unpack_s_StcHits(XDR* xdrs, popNode* pop)
{
   s_StcHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_StcHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_StcTruthPoints_t* unpack_s_StcTruthPoints(XDR* xdrs, popNode* pop)
{
   s_StcTruthPoints_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_StcTruthPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].dEdx);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].r);
         xdr_int(xdrs,&this1->in[m].sector);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_BarrelEMcal_t* unpack_s_BarrelEMcal(XDR* xdrs, popNode* pop)
{
   s_BarrelEMcal_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_BarrelEMcal();
      {
         int p;
         void* (*ptr) = (void**) &this1->bcalCells;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_BcalCells_t* unpack_s_BcalCells(XDR* xdrs, popNode* pop)
{
   s_BcalCells_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_BcalCells(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].bcalHits;
         xdr_int(xdrs,&this1->in[m].layer);
         xdr_int(xdrs,&this1->in[m].module);
         xdr_int(xdrs,&this1->in[m].sector);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_BcalHits_t* unpack_s_BcalHits(XDR* xdrs, popNode* pop)
{
   s_BcalHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_BcalHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_float(xdrs,&this1->in[m].zLocal);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_BcalTruthShowers_t* unpack_s_BcalTruthShowers(XDR* xdrs, popNode* pop)
{
   s_BcalTruthShowers_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_BcalTruthShowers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].r);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_GapEMcal_t* unpack_s_GapEMcal(XDR* xdrs, popNode* pop)
{
   s_GapEMcal_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_GapEMcal();
      {
         int p;
         void* (*ptr) = (void**) &this1->gcalCells;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_GcalCells_t* unpack_s_GcalCells(XDR* xdrs, popNode* pop)
{
   s_GcalCells_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_GcalCells(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].gcalHits;
         xdr_int(xdrs,&this1->in[m].module);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_GcalHits_t* unpack_s_GcalHits(XDR* xdrs, popNode* pop)
{
   s_GcalHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_GcalHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_float(xdrs,&this1->in[m].zLocal);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_GcalTruthShowers_t* unpack_s_GcalTruthShowers(XDR* xdrs, popNode* pop)
{
   s_GcalTruthShowers_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_GcalTruthShowers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].r);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Cerenkov_t* unpack_s_Cerenkov(XDR* xdrs, popNode* pop)
{
   s_Cerenkov_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Cerenkov();
      {
         int p;
         void* (*ptr) = (void**) &this1->cereSections;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CereSections_t* unpack_s_CereSections(XDR* xdrs, popNode* pop)
{
   s_CereSections_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CereSections(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].cereHits;
         xdr_int(xdrs,&this1->in[m].sector);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CereHits_t* unpack_s_CereHits(XDR* xdrs, popNode* pop)
{
   s_CereHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CereHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].pe);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CereTruthPoints_t* unpack_s_CereTruthPoints(XDR* xdrs, popNode* pop)
{
   s_CereTruthPoints_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CereTruthPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardTOF_t* unpack_s_ForwardTOF(XDR* xdrs, popNode* pop)
{
   s_ForwardTOF_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_ForwardTOF();
      {
         int p;
         void* (*ptr) = (void**) &this1->ftofCounters;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FtofCounters_t* unpack_s_FtofCounters(XDR* xdrs, popNode* pop)
{
   s_FtofCounters_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FtofCounters(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].ftofNorthHits;
         xdr_int(xdrs,&this1->in[m].bar);
         xdr_int(xdrs,&this1->in[m].plane);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FtofNorthHits_t* unpack_s_FtofNorthHits(XDR* xdrs, popNode* pop)
{
   s_FtofNorthHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FtofNorthHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FtofSouthHits_t* unpack_s_FtofSouthHits(XDR* xdrs, popNode* pop)
{
   s_FtofSouthHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FtofSouthHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FtofTruthPoints_t* unpack_s_FtofTruthPoints(XDR* xdrs, popNode* pop)
{
   s_FtofTruthPoints_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FtofTruthPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardEMcal_t* unpack_s_ForwardEMcal(XDR* xdrs, popNode* pop)
{
   s_ForwardEMcal_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_ForwardEMcal();
      {
         int p;
         void* (*ptr) = (void**) &this1->fcalBlocks;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FcalBlocks_t* unpack_s_FcalBlocks(XDR* xdrs, popNode* pop)
{
   s_FcalBlocks_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FcalBlocks(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].fcalHits;
         xdr_int(xdrs,&this1->in[m].column);
         xdr_int(xdrs,&this1->in[m].row);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FcalHits_t* unpack_s_FcalHits(XDR* xdrs, popNode* pop)
{
   s_FcalHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FcalHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FcalTruthShowers_t* unpack_s_FcalTruthShowers(XDR* xdrs, popNode* pop)
{
   s_FcalTruthShowers_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FcalTruthShowers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_UpstreamEMveto_t* unpack_s_UpstreamEMveto(XDR* xdrs, popNode* pop)
{
   s_UpstreamEMveto_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_UpstreamEMveto();
      {
         int p;
         void* (*ptr) = (void**) &this1->upvPaddles;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_UpvPaddles_t* unpack_s_UpvPaddles(XDR* xdrs, popNode* pop)
{
   s_UpvPaddles_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_UpvPaddles(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].upvLeftHits;
         xdr_int(xdrs,&this1->in[m].layer);
         xdr_int(xdrs,&this1->in[m].row);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_UpvLeftHits_t* unpack_s_UpvLeftHits(XDR* xdrs, popNode* pop)
{
   s_UpvLeftHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_UpvLeftHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_UpvRightHits_t* unpack_s_UpvRightHits(XDR* xdrs, popNode* pop)
{
   s_UpvRightHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_UpvRightHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_UpvTruthShowers_t* unpack_s_UpvTruthShowers(XDR* xdrs, popNode* pop)
{
   s_UpvTruthShowers_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_UpvTruthShowers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_bool(xdrs,&this1->in[m].primary);
         xdr_int(xdrs,&this1->in[m].ptype);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Tagger_t* unpack_s_Tagger(XDR* xdrs, popNode* pop)
{
   s_Tagger_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Tagger();
      {
         int p;
         void* (*ptr) = (void**) &this1->microChannels;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_MicroChannels_t* unpack_s_MicroChannels(XDR* xdrs, popNode* pop)
{
   s_MicroChannels_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_MicroChannels(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].taggerHits;
         xdr_float(xdrs,&this1->in[m].E);
         xdr_int(xdrs,&this1->in[m].column);
         xdr_int(xdrs,&this1->in[m].row);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_TaggerHits_t* unpack_s_TaggerHits(XDR* xdrs, popNode* pop)
{
   s_TaggerHits_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_TaggerHits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_McTrajectory_t* unpack_s_McTrajectory(XDR* xdrs, popNode* pop)
{
   s_McTrajectory_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_McTrajectory();
      {
         int p;
         void* (*ptr) = (void**) &this1->mcTrajectoryPoints;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_McTrajectoryPoints_t* unpack_s_McTrajectoryPoints(XDR* xdrs, popNode* pop)
{
   s_McTrajectoryPoints_t* this1 = HDDM_NULL;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return this1;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      unsigned int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_McTrajectoryPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_int(xdrs,&this1->in[m].mech);
         xdr_int(xdrs,&this1->in[m].part);
         xdr_int(xdrs,&this1->in[m].primary_track);
         xdr_float(xdrs,&this1->in[m].px);
         xdr_float(xdrs,&this1->in[m].py);
         xdr_float(xdrs,&this1->in[m].pz);
         xdr_float(xdrs,&this1->in[m].radlen);
         xdr_float(xdrs,&this1->in[m].step);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

s_HDDM_t* read_s_HDDM(s_iostream_t* fp)
{
   s_HDDM_t* nextEvent = unpack_s_HDDM(fp->xdrs,fp->popTop);
   return (nextEvent == HDDM_NULL)? 0 : nextEvent;
}

int skip_s_HDDM(s_iostream_t* fp, int nskip)
{
   int skipped;
   for (skipped=0; skipped < nskip; ++skipped)
   {
      unsigned int size;
      if (! xdr_u_int(fp->xdrs,&size))
      {
          return skipped;
      }
      else if (size > 0)
      {
         int start = xdr_getpos(fp->xdrs);
         xdr_setpos(fp->xdrs,start+size);
      }
   }
   return skipped;
}

static int pack_s_HDDM(XDR* xdrs, s_HDDM_t* this1);
static int pack_s_PhysicsEvents(XDR* xdrs, s_PhysicsEvents_t* this1);
static int pack_s_Reactions(XDR* xdrs, s_Reactions_t* this1);
static int pack_s_Beam(XDR* xdrs, s_Beam_t* this1);
static int pack_s_Momentum(XDR* xdrs, s_Momentum_t* this1);
static int pack_s_Properties(XDR* xdrs, s_Properties_t* this1);
static int pack_s_Target(XDR* xdrs, s_Target_t* this1);
static int pack_s_Vertices(XDR* xdrs, s_Vertices_t* this1);
static int pack_s_Products(XDR* xdrs, s_Products_t* this1);
static int pack_s_Origin(XDR* xdrs, s_Origin_t* this1);
static int pack_s_HitView(XDR* xdrs, s_HitView_t* this1);
static int pack_s_CentralDC(XDR* xdrs, s_CentralDC_t* this1);
static int pack_s_CdcStraws(XDR* xdrs, s_CdcStraws_t* this1);
static int pack_s_CdcStrawHits(XDR* xdrs, s_CdcStrawHits_t* this1);
static int pack_s_CdcTruthPoints(XDR* xdrs, s_CdcTruthPoints_t* this1);
static int pack_s_ForwardDC(XDR* xdrs, s_ForwardDC_t* this1);
static int pack_s_FdcChambers(XDR* xdrs, s_FdcChambers_t* this1);
static int pack_s_FdcAnodeWires(XDR* xdrs, s_FdcAnodeWires_t* this1);
static int pack_s_FdcAnodeHits(XDR* xdrs, s_FdcAnodeHits_t* this1);
static int pack_s_FdcCathodeStrips(XDR* xdrs, s_FdcCathodeStrips_t* this1);
static int pack_s_FdcCathodeHits(XDR* xdrs, s_FdcCathodeHits_t* this1);
static int pack_s_FdcTruthPoints(XDR* xdrs, s_FdcTruthPoints_t* this1);
static int pack_s_StartCntr(XDR* xdrs, s_StartCntr_t* this1);
static int pack_s_StcPaddles(XDR* xdrs, s_StcPaddles_t* this1);
static int pack_s_StcHits(XDR* xdrs, s_StcHits_t* this1);
static int pack_s_StcTruthPoints(XDR* xdrs, s_StcTruthPoints_t* this1);
static int pack_s_BarrelEMcal(XDR* xdrs, s_BarrelEMcal_t* this1);
static int pack_s_BcalCells(XDR* xdrs, s_BcalCells_t* this1);
static int pack_s_BcalHits(XDR* xdrs, s_BcalHits_t* this1);
static int pack_s_BcalTruthShowers(XDR* xdrs, s_BcalTruthShowers_t* this1);
static int pack_s_GapEMcal(XDR* xdrs, s_GapEMcal_t* this1);
static int pack_s_GcalCells(XDR* xdrs, s_GcalCells_t* this1);
static int pack_s_GcalHits(XDR* xdrs, s_GcalHits_t* this1);
static int pack_s_GcalTruthShowers(XDR* xdrs, s_GcalTruthShowers_t* this1);
static int pack_s_Cerenkov(XDR* xdrs, s_Cerenkov_t* this1);
static int pack_s_CereSections(XDR* xdrs, s_CereSections_t* this1);
static int pack_s_CereHits(XDR* xdrs, s_CereHits_t* this1);
static int pack_s_CereTruthPoints(XDR* xdrs, s_CereTruthPoints_t* this1);
static int pack_s_ForwardTOF(XDR* xdrs, s_ForwardTOF_t* this1);
static int pack_s_FtofCounters(XDR* xdrs, s_FtofCounters_t* this1);
static int pack_s_FtofNorthHits(XDR* xdrs, s_FtofNorthHits_t* this1);
static int pack_s_FtofSouthHits(XDR* xdrs, s_FtofSouthHits_t* this1);
static int pack_s_FtofTruthPoints(XDR* xdrs, s_FtofTruthPoints_t* this1);
static int pack_s_ForwardEMcal(XDR* xdrs, s_ForwardEMcal_t* this1);
static int pack_s_FcalBlocks(XDR* xdrs, s_FcalBlocks_t* this1);
static int pack_s_FcalHits(XDR* xdrs, s_FcalHits_t* this1);
static int pack_s_FcalTruthShowers(XDR* xdrs, s_FcalTruthShowers_t* this1);
static int pack_s_UpstreamEMveto(XDR* xdrs, s_UpstreamEMveto_t* this1);
static int pack_s_UpvPaddles(XDR* xdrs, s_UpvPaddles_t* this1);
static int pack_s_UpvLeftHits(XDR* xdrs, s_UpvLeftHits_t* this1);
static int pack_s_UpvRightHits(XDR* xdrs, s_UpvRightHits_t* this1);
static int pack_s_UpvTruthShowers(XDR* xdrs, s_UpvTruthShowers_t* this1);
static int pack_s_Tagger(XDR* xdrs, s_Tagger_t* this1);
static int pack_s_MicroChannels(XDR* xdrs, s_MicroChannels_t* this1);
static int pack_s_TaggerHits(XDR* xdrs, s_TaggerHits_t* this1);
static int pack_s_McTrajectory(XDR* xdrs, s_McTrajectory_t* this1);
static int pack_s_McTrajectoryPoints(XDR* xdrs, s_McTrajectoryPoints_t* this1);

static int pack_s_HDDM(XDR* xdrs, s_HDDM_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->physicsEvents != (s_PhysicsEvents_t*)&hddm_nullTarget)
      {
         pack_s_PhysicsEvents(xdrs,this1->physicsEvents);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_PhysicsEvents(XDR* xdrs, s_PhysicsEvents_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].eventNo);
      xdr_int(xdrs,&this1->in[m].runNo);
      if (this1->in[m].reactions != (s_Reactions_t*)&hddm_nullTarget)
      {
         pack_s_Reactions(xdrs,this1->in[m].reactions);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].hitView != (s_HitView_t*)&hddm_nullTarget)
      {
         pack_s_HitView(xdrs,this1->in[m].hitView);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Reactions(XDR* xdrs, s_Reactions_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].type);
      xdr_float(xdrs,&this1->in[m].weight);
      if (this1->in[m].beam != (s_Beam_t*)&hddm_nullTarget)
      {
         pack_s_Beam(xdrs,this1->in[m].beam);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].target != (s_Target_t*)&hddm_nullTarget)
      {
         pack_s_Target(xdrs,this1->in[m].target);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].vertices != (s_Vertices_t*)&hddm_nullTarget)
      {
         pack_s_Vertices(xdrs,this1->in[m].vertices);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Beam(XDR* xdrs, s_Beam_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      xdr_int(xdrs,(int*)&this1->type);
      if (this1->momentum != (s_Momentum_t*)&hddm_nullTarget)
      {
         pack_s_Momentum(xdrs,this1->momentum);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->properties != (s_Properties_t*)&hddm_nullTarget)
      {
         pack_s_Properties(xdrs,this1->properties);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Momentum(XDR* xdrs, s_Momentum_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      xdr_float(xdrs,&this1->E);
      xdr_float(xdrs,&this1->px);
      xdr_float(xdrs,&this1->py);
      xdr_float(xdrs,&this1->pz);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Properties(XDR* xdrs, s_Properties_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      xdr_int(xdrs,&this1->charge);
      xdr_float(xdrs,&this1->mass);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Target(XDR* xdrs, s_Target_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      xdr_int(xdrs,(int*)&this1->type);
      if (this1->momentum != (s_Momentum_t*)&hddm_nullTarget)
      {
         pack_s_Momentum(xdrs,this1->momentum);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->properties != (s_Properties_t*)&hddm_nullTarget)
      {
         pack_s_Properties(xdrs,this1->properties);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Vertices(XDR* xdrs, s_Vertices_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      if (this1->in[m].products != (s_Products_t*)&hddm_nullTarget)
      {
         pack_s_Products(xdrs,this1->in[m].products);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].origin != (s_Origin_t*)&hddm_nullTarget)
      {
         pack_s_Origin(xdrs,this1->in[m].origin);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Products(XDR* xdrs, s_Products_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].decayVertex);
      xdr_int(xdrs,&this1->in[m].id);
      xdr_int(xdrs,&this1->in[m].mech);
      xdr_int(xdrs,&this1->in[m].parentid);
      xdr_int(xdrs,&this1->in[m].pdgtype);
      xdr_int(xdrs,(int*)&this1->in[m].type);
      if (this1->in[m].momentum != (s_Momentum_t*)&hddm_nullTarget)
      {
         pack_s_Momentum(xdrs,this1->in[m].momentum);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].properties != (s_Properties_t*)&hddm_nullTarget)
      {
         pack_s_Properties(xdrs,this1->in[m].properties);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Origin(XDR* xdrs, s_Origin_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      xdr_float(xdrs,&this1->t);
      xdr_float(xdrs,&this1->vx);
      xdr_float(xdrs,&this1->vy);
      xdr_float(xdrs,&this1->vz);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_HitView(XDR* xdrs, s_HitView_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->centralDC != (s_CentralDC_t*)&hddm_nullTarget)
      {
         pack_s_CentralDC(xdrs,this1->centralDC);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardDC != (s_ForwardDC_t*)&hddm_nullTarget)
      {
         pack_s_ForwardDC(xdrs,this1->forwardDC);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->startCntr != (s_StartCntr_t*)&hddm_nullTarget)
      {
         pack_s_StartCntr(xdrs,this1->startCntr);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->barrelEMcal != (s_BarrelEMcal_t*)&hddm_nullTarget)
      {
         pack_s_BarrelEMcal(xdrs,this1->barrelEMcal);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->gapEMcal != (s_GapEMcal_t*)&hddm_nullTarget)
      {
         pack_s_GapEMcal(xdrs,this1->gapEMcal);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->Cerenkov != (s_Cerenkov_t*)&hddm_nullTarget)
      {
         pack_s_Cerenkov(xdrs,this1->Cerenkov);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardTOF != (s_ForwardTOF_t*)&hddm_nullTarget)
      {
         pack_s_ForwardTOF(xdrs,this1->forwardTOF);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardEMcal != (s_ForwardEMcal_t*)&hddm_nullTarget)
      {
         pack_s_ForwardEMcal(xdrs,this1->forwardEMcal);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->upstreamEMveto != (s_UpstreamEMveto_t*)&hddm_nullTarget)
      {
         pack_s_UpstreamEMveto(xdrs,this1->upstreamEMveto);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->tagger != (s_Tagger_t*)&hddm_nullTarget)
      {
         pack_s_Tagger(xdrs,this1->tagger);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->mcTrajectory != (s_McTrajectory_t*)&hddm_nullTarget)
      {
         pack_s_McTrajectory(xdrs,this1->mcTrajectory);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CentralDC(XDR* xdrs, s_CentralDC_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->cdcStraws != (s_CdcStraws_t*)&hddm_nullTarget)
      {
         pack_s_CdcStraws(xdrs,this1->cdcStraws);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->cdcTruthPoints != (s_CdcTruthPoints_t*)&hddm_nullTarget)
      {
         pack_s_CdcTruthPoints(xdrs,this1->cdcTruthPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CdcStraws(XDR* xdrs, s_CdcStraws_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].ring);
      xdr_int(xdrs,&this1->in[m].straw);
      if (this1->in[m].cdcStrawHits != (s_CdcStrawHits_t*)&hddm_nullTarget)
      {
         pack_s_CdcStrawHits(xdrs,this1->in[m].cdcStrawHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CdcStrawHits(XDR* xdrs, s_CdcStrawHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CdcTruthPoints(XDR* xdrs, s_CdcTruthPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dEdx);
      xdr_float(xdrs,&this1->in[m].dradius);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].r);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardDC(XDR* xdrs, s_ForwardDC_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->fdcChambers != (s_FdcChambers_t*)&hddm_nullTarget)
      {
         pack_s_FdcChambers(xdrs,this1->fdcChambers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcChambers(XDR* xdrs, s_FdcChambers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].layer);
      xdr_int(xdrs,&this1->in[m].module);
      if (this1->in[m].fdcAnodeWires != (s_FdcAnodeWires_t*)&hddm_nullTarget)
      {
         pack_s_FdcAnodeWires(xdrs,this1->in[m].fdcAnodeWires);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].fdcCathodeStrips != (s_FdcCathodeStrips_t*)&hddm_nullTarget)
      {
         pack_s_FdcCathodeStrips(xdrs,this1->in[m].fdcCathodeStrips);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].fdcTruthPoints != (s_FdcTruthPoints_t*)&hddm_nullTarget)
      {
         pack_s_FdcTruthPoints(xdrs,this1->in[m].fdcTruthPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcAnodeWires(XDR* xdrs, s_FdcAnodeWires_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].wire);
      if (this1->in[m].fdcAnodeHits != (s_FdcAnodeHits_t*)&hddm_nullTarget)
      {
         pack_s_FdcAnodeHits(xdrs,this1->in[m].fdcAnodeHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcAnodeHits(XDR* xdrs, s_FdcAnodeHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcCathodeStrips(XDR* xdrs, s_FdcCathodeStrips_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].plane);
      xdr_int(xdrs,&this1->in[m].strip);
      if (this1->in[m].fdcCathodeHits != (s_FdcCathodeHits_t*)&hddm_nullTarget)
      {
         pack_s_FdcCathodeHits(xdrs,this1->in[m].fdcCathodeHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcCathodeHits(XDR* xdrs, s_FdcCathodeHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].q);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcTruthPoints(XDR* xdrs, s_FdcTruthPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].dEdx);
      xdr_float(xdrs,&this1->in[m].dradius);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_StartCntr(XDR* xdrs, s_StartCntr_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->stcPaddles != (s_StcPaddles_t*)&hddm_nullTarget)
      {
         pack_s_StcPaddles(xdrs,this1->stcPaddles);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->stcTruthPoints != (s_StcTruthPoints_t*)&hddm_nullTarget)
      {
         pack_s_StcTruthPoints(xdrs,this1->stcTruthPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_StcPaddles(XDR* xdrs, s_StcPaddles_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].sector);
      if (this1->in[m].stcHits != (s_StcHits_t*)&hddm_nullTarget)
      {
         pack_s_StcHits(xdrs,this1->in[m].stcHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_StcHits(XDR* xdrs, s_StcHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_StcTruthPoints(XDR* xdrs, s_StcTruthPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].dEdx);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].r);
      xdr_int(xdrs,&this1->in[m].sector);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_BarrelEMcal(XDR* xdrs, s_BarrelEMcal_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->bcalCells != (s_BcalCells_t*)&hddm_nullTarget)
      {
         pack_s_BcalCells(xdrs,this1->bcalCells);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->bcalTruthShowers != (s_BcalTruthShowers_t*)&hddm_nullTarget)
      {
         pack_s_BcalTruthShowers(xdrs,this1->bcalTruthShowers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_BcalCells(XDR* xdrs, s_BcalCells_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].layer);
      xdr_int(xdrs,&this1->in[m].module);
      xdr_int(xdrs,&this1->in[m].sector);
      if (this1->in[m].bcalHits != (s_BcalHits_t*)&hddm_nullTarget)
      {
         pack_s_BcalHits(xdrs,this1->in[m].bcalHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_BcalHits(XDR* xdrs, s_BcalHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_float(xdrs,&this1->in[m].zLocal);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_BcalTruthShowers(XDR* xdrs, s_BcalTruthShowers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].r);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_GapEMcal(XDR* xdrs, s_GapEMcal_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->gcalCells != (s_GcalCells_t*)&hddm_nullTarget)
      {
         pack_s_GcalCells(xdrs,this1->gcalCells);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->gcalTruthShowers != (s_GcalTruthShowers_t*)&hddm_nullTarget)
      {
         pack_s_GcalTruthShowers(xdrs,this1->gcalTruthShowers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_GcalCells(XDR* xdrs, s_GcalCells_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].module);
      if (this1->in[m].gcalHits != (s_GcalHits_t*)&hddm_nullTarget)
      {
         pack_s_GcalHits(xdrs,this1->in[m].gcalHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_GcalHits(XDR* xdrs, s_GcalHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_float(xdrs,&this1->in[m].zLocal);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_GcalTruthShowers(XDR* xdrs, s_GcalTruthShowers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].r);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Cerenkov(XDR* xdrs, s_Cerenkov_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->cereSections != (s_CereSections_t*)&hddm_nullTarget)
      {
         pack_s_CereSections(xdrs,this1->cereSections);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->cereTruthPoints != (s_CereTruthPoints_t*)&hddm_nullTarget)
      {
         pack_s_CereTruthPoints(xdrs,this1->cereTruthPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CereSections(XDR* xdrs, s_CereSections_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].sector);
      if (this1->in[m].cereHits != (s_CereHits_t*)&hddm_nullTarget)
      {
         pack_s_CereHits(xdrs,this1->in[m].cereHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CereHits(XDR* xdrs, s_CereHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].pe);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CereTruthPoints(XDR* xdrs, s_CereTruthPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardTOF(XDR* xdrs, s_ForwardTOF_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->ftofCounters != (s_FtofCounters_t*)&hddm_nullTarget)
      {
         pack_s_FtofCounters(xdrs,this1->ftofCounters);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->ftofTruthPoints != (s_FtofTruthPoints_t*)&hddm_nullTarget)
      {
         pack_s_FtofTruthPoints(xdrs,this1->ftofTruthPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FtofCounters(XDR* xdrs, s_FtofCounters_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].bar);
      xdr_int(xdrs,&this1->in[m].plane);
      if (this1->in[m].ftofNorthHits != (s_FtofNorthHits_t*)&hddm_nullTarget)
      {
         pack_s_FtofNorthHits(xdrs,this1->in[m].ftofNorthHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].ftofSouthHits != (s_FtofSouthHits_t*)&hddm_nullTarget)
      {
         pack_s_FtofSouthHits(xdrs,this1->in[m].ftofSouthHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FtofNorthHits(XDR* xdrs, s_FtofNorthHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FtofSouthHits(XDR* xdrs, s_FtofSouthHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FtofTruthPoints(XDR* xdrs, s_FtofTruthPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardEMcal(XDR* xdrs, s_ForwardEMcal_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->fcalBlocks != (s_FcalBlocks_t*)&hddm_nullTarget)
      {
         pack_s_FcalBlocks(xdrs,this1->fcalBlocks);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->fcalTruthShowers != (s_FcalTruthShowers_t*)&hddm_nullTarget)
      {
         pack_s_FcalTruthShowers(xdrs,this1->fcalTruthShowers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FcalBlocks(XDR* xdrs, s_FcalBlocks_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].column);
      xdr_int(xdrs,&this1->in[m].row);
      if (this1->in[m].fcalHits != (s_FcalHits_t*)&hddm_nullTarget)
      {
         pack_s_FcalHits(xdrs,this1->in[m].fcalHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FcalHits(XDR* xdrs, s_FcalHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FcalTruthShowers(XDR* xdrs, s_FcalTruthShowers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_UpstreamEMveto(XDR* xdrs, s_UpstreamEMveto_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->upvPaddles != (s_UpvPaddles_t*)&hddm_nullTarget)
      {
         pack_s_UpvPaddles(xdrs,this1->upvPaddles);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->upvTruthShowers != (s_UpvTruthShowers_t*)&hddm_nullTarget)
      {
         pack_s_UpvTruthShowers(xdrs,this1->upvTruthShowers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_UpvPaddles(XDR* xdrs, s_UpvPaddles_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].layer);
      xdr_int(xdrs,&this1->in[m].row);
      if (this1->in[m].upvLeftHits != (s_UpvLeftHits_t*)&hddm_nullTarget)
      {
         pack_s_UpvLeftHits(xdrs,this1->in[m].upvLeftHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].upvRightHits != (s_UpvRightHits_t*)&hddm_nullTarget)
      {
         pack_s_UpvRightHits(xdrs,this1->in[m].upvRightHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_UpvLeftHits(XDR* xdrs, s_UpvLeftHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_UpvRightHits(XDR* xdrs, s_UpvRightHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_UpvTruthShowers(XDR* xdrs, s_UpvTruthShowers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_bool(xdrs,&this1->in[m].primary);
      xdr_int(xdrs,&this1->in[m].ptype);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Tagger(XDR* xdrs, s_Tagger_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->microChannels != (s_MicroChannels_t*)&hddm_nullTarget)
      {
         pack_s_MicroChannels(xdrs,this1->microChannels);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_MicroChannels(XDR* xdrs, s_MicroChannels_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_int(xdrs,&this1->in[m].column);
      xdr_int(xdrs,&this1->in[m].row);
      if (this1->in[m].taggerHits != (s_TaggerHits_t*)&hddm_nullTarget)
      {
         pack_s_TaggerHits(xdrs,this1->in[m].taggerHits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_TaggerHits(XDR* xdrs, s_TaggerHits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_McTrajectory(XDR* xdrs, s_McTrajectory_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   m = 0; /* avoid warnings from -Wall */
   {
      if (this1->mcTrajectoryPoints != (s_McTrajectoryPoints_t*)&hddm_nullTarget)
      {
         pack_s_McTrajectoryPoints(xdrs,this1->mcTrajectoryPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_McTrajectoryPoints(XDR* xdrs, s_McTrajectoryPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_int(xdrs,&this1->in[m].mech);
      xdr_int(xdrs,&this1->in[m].part);
      xdr_int(xdrs,&this1->in[m].primary_track);
      xdr_float(xdrs,&this1->in[m].px);
      xdr_float(xdrs,&this1->in[m].py);
      xdr_float(xdrs,&this1->in[m].pz);
      xdr_float(xdrs,&this1->in[m].radlen);
      xdr_float(xdrs,&this1->in[m].step);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

int flush_s_HDDM(s_HDDM_t* this1,s_iostream_t* fp)
{
   if (this1 == 0)
   {
      return 0;
   }
   else if (fp == 0)
   {
      XDR* xdrs = (XDR*)malloc(sizeof(XDR));
      int max_buffer_size = 1000000;
      char* dump = (char*)malloc(max_buffer_size);
      xdrmem_create(xdrs,dump,max_buffer_size,XDR_ENCODE);
      pack_s_HDDM(xdrs,this1);
      xdr_destroy(xdrs);
      free(xdrs);
      free(dump);
      return 0;
   }
   else if (fp->iomode == HDDM_STREAM_OUTPUT)
   {
      pack_s_HDDM(fp->xdrs,this1);
      return 0;
   }
   return 0;
}

static int getTag(char* d, char* tag)
{
   int level;
   char* token;
   char line[500];
   strncpy(line,d,500);
   line[499] = 0;
   level = index(line,'<')-line;
   if (level < 500 &&
      (token = strtok(line+level+1," >")))
   {
      strncpy(tag,token,500);
      return level/2;
   }
   return -1;
}

static char* getEndTag(char* d, char* tag)
{
   char line[500];
   char endTag[510];
   strncpy(line,d,500);
   line[499] = 0;
   if (strstr(strtok(line,"\n"),"/>") == 0)
   {
      sprintf(endTag,"</%s>",tag);
   }
   else
   {
      strcpy(endTag,"/>");
   }
   return strstr(d,endTag);
}

static void collide(char* b, char* c)
{
   char btag[500];
   getTag(b,btag);
   b = index(b,'<');
   c = index(c,'<');
   *(index(b,'\n')) = 0;
   *(index(c,'\n')) = 0;
   fprintf(stderr,"HDDM warning: ");
   fprintf(stderr,"tag %s in input file ", btag);
   fprintf(stderr,"does not match c header hddm_s.h\n");
   fprintf(stderr,"  input file: %s\n", b);
   fprintf(stderr,"  c header: %s\n", c);
   fprintf(stderr,"  === Tag %s will be ignored,", btag);
   fprintf(stderr," rebuild to cure the problem ===\n");
   *(index(b,0)) = '\n';
   *(index(c,0)) = '\n';
}

static popNode* matches(char* b, char* c)
{
   char btag[500];
   char ctag[500];
   int blevel, clevel;
   int ptrSeqNo = 0;
   blevel = getTag(b,btag);
   while ((clevel = getTag(c,ctag)) == blevel)
   {
      if ((clevel == blevel) && (strcmp(ctag,btag) == 0))
      {
         popNode* this1 = (popNode*)malloc(sizeof(popNode));
         int len = index(c+1,'\n') - c;
         if (strncmp(c,b,len) != 0)
         {
            collide(b,c);
            return 0;
         }
         else if (strcmp(btag,"HDDM") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_HDDM;
         }
         else if (strcmp(btag,"physicsEvent") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_PhysicsEvents;
         }
         else if (strcmp(btag,"reaction") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Reactions;
         }
         else if (strcmp(btag,"beam") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Beam;
         }
         else if (strcmp(btag,"momentum") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Momentum;
         }
         else if (strcmp(btag,"properties") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Properties;
         }
         else if (strcmp(btag,"target") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Target;
         }
         else if (strcmp(btag,"vertex") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Vertices;
         }
         else if (strcmp(btag,"product") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Products;
         }
         else if (strcmp(btag,"origin") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Origin;
         }
         else if (strcmp(btag,"hitView") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_HitView;
         }
         else if (strcmp(btag,"centralDC") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CentralDC;
         }
         else if (strcmp(btag,"cdcStraw") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CdcStraws;
         }
         else if (strcmp(btag,"cdcStrawHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CdcStrawHits;
         }
         else if (strcmp(btag,"cdcTruthPoint") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CdcTruthPoints;
         }
         else if (strcmp(btag,"forwardDC") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_ForwardDC;
         }
         else if (strcmp(btag,"fdcChamber") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FdcChambers;
         }
         else if (strcmp(btag,"fdcAnodeWire") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FdcAnodeWires;
         }
         else if (strcmp(btag,"fdcAnodeHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FdcAnodeHits;
         }
         else if (strcmp(btag,"fdcCathodeStrip") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FdcCathodeStrips;
         }
         else if (strcmp(btag,"fdcCathodeHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FdcCathodeHits;
         }
         else if (strcmp(btag,"fdcTruthPoint") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FdcTruthPoints;
         }
         else if (strcmp(btag,"startCntr") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_StartCntr;
         }
         else if (strcmp(btag,"stcPaddle") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_StcPaddles;
         }
         else if (strcmp(btag,"stcHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_StcHits;
         }
         else if (strcmp(btag,"stcTruthPoint") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_StcTruthPoints;
         }
         else if (strcmp(btag,"barrelEMcal") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_BarrelEMcal;
         }
         else if (strcmp(btag,"bcalCell") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_BcalCells;
         }
         else if (strcmp(btag,"bcalHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_BcalHits;
         }
         else if (strcmp(btag,"bcalTruthShower") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_BcalTruthShowers;
         }
         else if (strcmp(btag,"gapEMcal") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_GapEMcal;
         }
         else if (strcmp(btag,"gcalCell") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_GcalCells;
         }
         else if (strcmp(btag,"gcalHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_GcalHits;
         }
         else if (strcmp(btag,"gcalTruthShower") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_GcalTruthShowers;
         }
         else if (strcmp(btag,"Cerenkov") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Cerenkov;
         }
         else if (strcmp(btag,"cereSection") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CereSections;
         }
         else if (strcmp(btag,"cereHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CereHits;
         }
         else if (strcmp(btag,"cereTruthPoint") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_CereTruthPoints;
         }
         else if (strcmp(btag,"forwardTOF") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_ForwardTOF;
         }
         else if (strcmp(btag,"ftofCounter") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FtofCounters;
         }
         else if (strcmp(btag,"ftofNorthHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FtofNorthHits;
         }
         else if (strcmp(btag,"ftofSouthHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FtofSouthHits;
         }
         else if (strcmp(btag,"ftofTruthPoint") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FtofTruthPoints;
         }
         else if (strcmp(btag,"forwardEMcal") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_ForwardEMcal;
         }
         else if (strcmp(btag,"fcalBlock") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FcalBlocks;
         }
         else if (strcmp(btag,"fcalHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FcalHits;
         }
         else if (strcmp(btag,"fcalTruthShower") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_FcalTruthShowers;
         }
         else if (strcmp(btag,"upstreamEMveto") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_UpstreamEMveto;
         }
         else if (strcmp(btag,"upvPaddle") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_UpvPaddles;
         }
         else if (strcmp(btag,"upvLeftHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_UpvLeftHits;
         }
         else if (strcmp(btag,"upvRightHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_UpvRightHits;
         }
         else if (strcmp(btag,"upvTruthShower") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_UpvTruthShowers;
         }
         else if (strcmp(btag,"tagger") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_Tagger;
         }
         else if (strcmp(btag,"microChannel") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_MicroChannels;
         }
         else if (strcmp(btag,"taggerHit") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_TaggerHits;
         }
         else if (strcmp(btag,"mcTrajectory") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_McTrajectory;
         }
         else if (strcmp(btag,"mcTrajectoryPoint") == 0)
         {
            this1->unpacker = (void*(*)(XDR*,popNode*))unpack_s_McTrajectoryPoints;
         }
         this1->inParent = ptrSeqNo;
         this1->popListLength = 0;
         c = index(c+1,'\n');
         b = index(b+1,'\n');
         while (getTag(b,btag) > blevel)
         {
            this1->popList[this1->popListLength++] = matches(b,c);
            if (this1->popListLength > 99)
            {
               fprintf(stderr,"hddm error - posList overflow.\n");
               fprintf(stderr,"Increase MAX_POPLIST_LENGTH and recompile.\n");
               exit(9);
            }
            b = getEndTag(b,btag);
            b = index(b+1,'\n');
         }
         return this1;
      }
      else
      {
         c = getEndTag(c,ctag);
         c = index(c+1,'\n');
         ++ptrSeqNo;
      }
   }
   return 0;
}

s_iostream_t* open_s_HDDM(char* filename)
{
   s_iostream_t* fp = (s_iostream_t*)malloc(sizeof(s_iostream_t));
   char* p;
   char* head;
   if (filename)
   {
      fp->fd = fopen(filename,"r");
   }
   else
   {
      fp->fd = fdopen(0,"r");
   }
   if (fp->fd == 0)
   {
      free(fp);
      return 0;
   }
   fp->iomode = HDDM_STREAM_INPUT;
   head = (char*)malloc(1000000);
   *head = 0;
   for (p = head;
        strstr(head,"</HDDM>") == 0;
        p += strlen(p))
   {
      if (p-head < 999000)
      {
         fgets(p,1000,fp->fd);
      }
      else
      {
         break;
      }
   }
   fp->popTop = matches(head,HDDM_s_DocumentString);
   free(head);
   if (fp->popTop->popListLength == 0)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"input template model ");
      fprintf(stderr,"does not match c header.");
      fprintf(stderr,"  Please recompile.\n");
      exit(9);
   }
   fp->filename = (char*)malloc(strlen(filename) + 1);
   strcpy(fp->filename,filename);
   fp->xdrs = (XDR*)malloc(sizeof(XDR));
   xdrstdio_create(fp->xdrs,fp->fd,XDR_DECODE);
   return fp;
}

s_iostream_t* init_s_HDDM(char* filename)
{
   int len;
   char* head;
   s_iostream_t* fp = (s_iostream_t*)malloc(sizeof(s_iostream_t));
   if (filename)
   {
      fp->fd = fopen(filename,"w");
   }
   else
   {
      fp->fd = fdopen(1,"w");
   }
   if (fp->fd == 0)
   {
      free(fp);
      return 0;
   }
   fp->iomode = HDDM_STREAM_OUTPUT;
   len = strlen(HDDM_s_DocumentString);
   head = (char*)malloc(len+1);
   strcpy(head,HDDM_s_DocumentString);
   if (fwrite(head,1,len,fp->fd) != len)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"error writing to ");
      fprintf(stderr,"output file %s\n",filename);
      exit(9);
   }
   fp->filename = (char*)malloc(strlen(filename) + 1);
   strcpy(fp->filename,filename);
   fp->popTop = 0;
   fp->xdrs = (XDR*)malloc(sizeof(XDR));
   xdrstdio_create(fp->xdrs,fp->fd,XDR_ENCODE);
   free(head);
   return fp;
}

static void popaway(popNode* p)
{
   if (p)
   {
      int n;
      for (n = 0; n < p->popListLength; n++)
      {
         popaway(p->popList[n]);
      }
      free(p);
   }
}

void close_s_HDDM(s_iostream_t* fp)
{
   xdr_destroy(fp->xdrs);
   free(fp->xdrs);
   fclose(fp->fd);
   free(fp->filename);
   popaway(fp->popTop);
   free(fp);
}
