#!/usr/bin/env perl

if($#ARGV < 0){&Usage();exit;}

$classname = $ARGV[0];
print "\n";
print "Generating files for factory $classname ";

$USE_TAG = 0;
if($#ARGV >= 1){
	$tag = $ARGV[1];
	$USE_TAG = 1;
	$tag_suffix = "_${tag}";
	print "with tag $tag ";
}
print "....\n";

if(!$USE_TAG){
	$hfile = $fname = "${classname}.h";
	open(FILE,">$hfile");
	&PrintFileHeader();
	&PrintDataClass();
	close(FILE);
	print " - $hfile\n";
}

$dhfile = $fname = "DFactory_${classname}${tag_suffix}.h";
open(FILE,">$dhfile");
&PrintFileHeader();
&PrintFactoryClass();
close(FILE);
print " - $dhfile\n";

$ccfile = $fname = "DFactory_${classname}${tag_suffix}.cc";
open(FILE,">$ccfile");
&PrintFileHeader();
&PrintFactoryMethods();
close(FILE);
print " - $ccfile\n";

print "\n";
if($USE_TAG){
print "The file $dhfile";
}else{
print "The files $hfile and $dhfile";
}
print " should be placed in the \n";
print "src/libraries/include directory. The $ccfile should be \n";
print "placed in the appropriate subdirectory in /src/libraries.\n";
print "\n";

###############
# PrintFileHeader
###############
sub PrintFileHeader()
{
	# print a few lines at the very top of the file
	$uname = `uname -nprs`;
	chomp($uname);
	print FILE "// \$Id\$\n";
	print FILE "//\n";
	print FILE "//    File: $fname\n";
	print FILE "// Created: ".`date`;
	print FILE "// Creator: ".$ENV{"USER"}." (on $uname)\n";
	print FILE "//\n";
}

###############
# PrintDataClass
###############
sub PrintDataClass()
{
	# perl doesn't respect scope unless explicitly told to. Hence,
	# all variables (like FILE and $classname) are global.

	$content = "
\#ifndef _${classname}_
\#define _${classname}_

\#include \"DObject.h\"
\#include \"DFactory.h\"

class ${classname}:public DObject{
	public:
		HDCLASSDEF(${classname});
		
};

\#endif // _${classname}_

";
	print FILE $content;
	
}

###############
# PrintFactoryClass
###############
sub PrintFactoryClass()
{
	$content = "
\#ifndef _DFactory_${classname}${tag_suffix}_
\#define _DFactory_${classname}${tag_suffix}_

\#include \"DFactory.h\"
\#include \"${classname}.h\"

class DFactory_${classname}${tag_suffix}:public DFactory<${classname}>{
	public:
		DFactory_${classname}${tag_suffix}(){};
		~DFactory_${classname}${tag_suffix}(){};
		const string toString(void);
";

	if($USE_TAG){
		$content .= "		const char* Tag(void){return \"$tag\";}";
	}

	$content .=	"

	private:
		derror_t evnt(DEventLoop *loop, int eventnumber);	///< Invoked via DEventProcessor virtual method
};

\#endif // _DFactory_${classname}${tag_suffix}_

";
	print FILE $content;
	
}

###############
# PrintDataMethods
###############
sub PrintFactoryMethods()
{
	$content = "
\#include \"DFactory_${classname}${tag_suffix}.h\"

//------------------
// evnt
//------------------
derror_t DFactory_${classname}${tag_suffix}::evnt(DEventLoop *loop, int eventnumber)
{
	// _data should be emptied before this method gets called
	assert( _data.size() == 0 );

	// Code to generate factory data goes here. Add it like:
	//
	// ${classname} *my${classname} = new ${classname};
	// my${classname}->x = x;
	// my${classname}->y = y;
	// ...
	// _data.push_back(my${classname});
	//
	// Note that the objects you create here will be deleted later
	// by the system and the _data vector will be cleared automatically.

	return NOERROR;
}

//------------------
// toString
//------------------
const string DFactory_${classname}${tag_suffix}::toString(void)
{
	// Ensure our Get method has been called so _data is up to date
	Get();
	if(_data.size()<=0)return string(); // don't print anything if we have no data!

	// Put the class specific code to produce nicely formatted ASCII here.
	// The DFactory_base class has several methods defined to help. They
	// rely on positions of colons (:) in the header. Here's an example:
	//
	//		printheader(\"row:    x:     y:\");
	//
	// 	for(int i=0; i<_data.size(); i++){
	//			${classname} *my${classname} = _data[i];
	//
	//			printnewrow();
	//			printcol(\"%d\",	i);
	//			printcol(\"%1.3f\",	my${classname}->x);
	//			printcol(\"%3.2f\",	my${classname}->y);
	//			printrow();
	//		}
	//
	return _table;

}
";
	print FILE $content;
	
}

###############
# Usage
###############
sub Usage()
{
	print "\n";
	print "Usage:\n\t mkfactory factory [tag]\n";
	print "\n";
	print "Generate the C++ source and header files to implement a new\n";
	print "data factory for the Hall-D analysis framework. The files will\n";
	print "define two classes. The first is has the name specified on\n";
	print "the command line and will be the class which actually holds\n";
	print "the data. The second is the factory class which is created from\n";
	print "a template and based on the first class.\n";
	print "\n";
	print "If the \"tag\" parameter is given, the factory is created\n";
	print "to provide data of the given type with the specified tag.\n";
	print "By default, factories have an empty tag. Giving a factory a\n";
	print "tag allows it to produce data based on the same class as another\n";
	print "factory produces. The two factories are distinguished by\n";
	print "their tags. If a tag is provided, it is assumed that the\n";
	print "data class already exists so only the factory's header\n";
	print "(and source) file is generated.\n";
	print "\n";
}
