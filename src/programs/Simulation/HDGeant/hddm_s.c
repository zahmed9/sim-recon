/*
 * hddm_s.c - DO NOT EDIT THIS FILE
 *
 * This file was generated automatically by hddm-c from the file
 * event.xml
 * This c file contains the i/o interface to the c structures
 * described in the data model (from event.xml). 
 * Any program that needs access to the data described in the model
 * can compile this source file, and make use of the input/output
 * services provided.
 *
 * The hddm data model tool set was written by
 * Richard Jones, University of Connecticut.
 *
 * For more information see the following web site
 *
 * http://zeus.phys.uconn.edu/halld/datamodel/doc
 */

#include "hddm_s.h"

s_HDDM_t* make_s_HDDM()
{
   int size = sizeof(s_HDDM_t);
   s_HDDM_t* p = CALLOC(size,"s_HDDM_t");
   return p;
}

s_PhysicsEvents_t* make_s_PhysicsEvents(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_PhysicsEvents_t) + rep * sizeof(s_PhysicsEvent_t);
   s_PhysicsEvents_t* p = CALLOC(size,"s_PhysicsEvents_t");
   return p;
}

s_Reactions_t* make_s_Reactions(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Reactions_t) + rep * sizeof(s_Reaction_t);
   s_Reactions_t* p = CALLOC(size,"s_Reactions_t");
   return p;
}

s_Beam_t* make_s_Beam()
{
   int size = sizeof(s_Beam_t);
   s_Beam_t* p = CALLOC(size,"s_Beam_t");
   return p;
}

s_Momentum_t* make_s_Momentum()
{
   int size = sizeof(s_Momentum_t);
   s_Momentum_t* p = CALLOC(size,"s_Momentum_t");
   return p;
}

s_Properties_t* make_s_Properties()
{
   int size = sizeof(s_Properties_t);
   s_Properties_t* p = CALLOC(size,"s_Properties_t");
   return p;
}

s_Target_t* make_s_Target()
{
   int size = sizeof(s_Target_t);
   s_Target_t* p = CALLOC(size,"s_Target_t");
   return p;
}

s_Vertices_t* make_s_Vertices(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Vertices_t) + rep * sizeof(s_Vertex_t);
   s_Vertices_t* p = CALLOC(size,"s_Vertices_t");
   return p;
}

s_Products_t* make_s_Products(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Products_t) + rep * sizeof(s_Product_t);
   s_Products_t* p = CALLOC(size,"s_Products_t");
   return p;
}

s_Origin_t* make_s_Origin()
{
   int size = sizeof(s_Origin_t);
   s_Origin_t* p = CALLOC(size,"s_Origin_t");
   return p;
}

s_HitView_t* make_s_HitView()
{
   int size = sizeof(s_HitView_t);
   s_HitView_t* p = CALLOC(size,"s_HitView_t");
   return p;
}

s_CentralDC_t* make_s_CentralDC()
{
   int size = sizeof(s_CentralDC_t);
   s_CentralDC_t* p = CALLOC(size,"s_CentralDC_t");
   return p;
}

s_CathodeCyls_t* make_s_CathodeCyls(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CathodeCyls_t) + rep * sizeof(s_CathodeCyl_t);
   s_CathodeCyls_t* p = CALLOC(size,"s_CathodeCyls_t");
   return p;
}

s_Bands_t* make_s_Bands(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Bands_t) + rep * sizeof(s_Band_t);
   s_Bands_t* p = CALLOC(size,"s_Bands_t");
   return p;
}

s_Rings_t* make_s_Rings(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Rings_t) + rep * sizeof(s_Ring_t);
   s_Rings_t* p = CALLOC(size,"s_Rings_t");
   return p;
}

s_Straws_t* make_s_Straws(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Straws_t) + rep * sizeof(s_Straw_t);
   s_Straws_t* p = CALLOC(size,"s_Straws_t");
   return p;
}

s_Hits_t* make_s_Hits(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Hits_t) + rep * sizeof(s_Hit_t);
   s_Hits_t* p = CALLOC(size,"s_Hits_t");
   return p;
}

s_CdcPoints_t* make_s_CdcPoints(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CdcPoints_t) + rep * sizeof(s_CdcPoint_t);
   s_CdcPoints_t* p = CALLOC(size,"s_CdcPoints_t");
   return p;
}

s_ForwardDC_t* make_s_ForwardDC()
{
   int size = sizeof(s_ForwardDC_t);
   s_ForwardDC_t* p = CALLOC(size,"s_ForwardDC_t");
   return p;
}

s_Chambers_t* make_s_Chambers(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Chambers_t) + rep * sizeof(s_Chamber_t);
   s_Chambers_t* p = CALLOC(size,"s_Chambers_t");
   return p;
}

s_CathodePlanes_t* make_s_CathodePlanes(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_CathodePlanes_t) + rep * sizeof(s_CathodePlane_t);
   s_CathodePlanes_t* p = CALLOC(size,"s_CathodePlanes_t");
   return p;
}

s_Strips_t* make_s_Strips(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Strips_t) + rep * sizeof(s_Strip_t);
   s_Strips_t* p = CALLOC(size,"s_Strips_t");
   return p;
}

s_AnodePlanes_t* make_s_AnodePlanes(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_AnodePlanes_t) + rep * sizeof(s_AnodePlane_t);
   s_AnodePlanes_t* p = CALLOC(size,"s_AnodePlanes_t");
   return p;
}

s_Wires_t* make_s_Wires(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Wires_t) + rep * sizeof(s_Wire_t);
   s_Wires_t* p = CALLOC(size,"s_Wires_t");
   return p;
}

s_FdcPoints_t* make_s_FdcPoints(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_FdcPoints_t) + rep * sizeof(s_FdcPoint_t);
   s_FdcPoints_t* p = CALLOC(size,"s_FdcPoints_t");
   return p;
}

s_StartCntr_t* make_s_StartCntr()
{
   int size = sizeof(s_StartCntr_t);
   s_StartCntr_t* p = CALLOC(size,"s_StartCntr_t");
   return p;
}

s_Paddles_t* make_s_Paddles(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Paddles_t) + rep * sizeof(s_Paddle_t);
   s_Paddles_t* p = CALLOC(size,"s_Paddles_t");
   return p;
}

s_StartPoints_t* make_s_StartPoints(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_StartPoints_t) + rep * sizeof(s_StartPoint_t);
   s_StartPoints_t* p = CALLOC(size,"s_StartPoints_t");
   return p;
}

s_BarrelEMcal_t* make_s_BarrelEMcal()
{
   int size = sizeof(s_BarrelEMcal_t);
   s_BarrelEMcal_t* p = CALLOC(size,"s_BarrelEMcal_t");
   return p;
}

s_Modules_t* make_s_Modules(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Modules_t) + rep * sizeof(s_Module_t);
   s_Modules_t* p = CALLOC(size,"s_Modules_t");
   return p;
}

s_Upstream_t* make_s_Upstream()
{
   int size = sizeof(s_Upstream_t);
   s_Upstream_t* p = CALLOC(size,"s_Upstream_t");
   return p;
}

s_Showers_t* make_s_Showers(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Showers_t) + rep * sizeof(s_Shower_t);
   s_Showers_t* p = CALLOC(size,"s_Showers_t");
   return p;
}

s_Downstream_t* make_s_Downstream()
{
   int size = sizeof(s_Downstream_t);
   s_Downstream_t* p = CALLOC(size,"s_Downstream_t");
   return p;
}

s_BarrelShowers_t* make_s_BarrelShowers(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_BarrelShowers_t) + rep * sizeof(s_BarrelShower_t);
   s_BarrelShowers_t* p = CALLOC(size,"s_BarrelShowers_t");
   return p;
}

s_Cerenkov_t* make_s_Cerenkov()
{
   int size = sizeof(s_Cerenkov_t);
   s_Cerenkov_t* p = CALLOC(size,"s_Cerenkov_t");
   return p;
}

s_Sections_t* make_s_Sections(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Sections_t) + rep * sizeof(s_Section_t);
   s_Sections_t* p = CALLOC(size,"s_Sections_t");
   return p;
}

s_Flashes_t* make_s_Flashes(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Flashes_t) + rep * sizeof(s_Flash_t);
   s_Flashes_t* p = CALLOC(size,"s_Flashes_t");
   return p;
}

s_ForwardTOF_t* make_s_ForwardTOF()
{
   int size = sizeof(s_ForwardTOF_t);
   s_ForwardTOF_t* p = CALLOC(size,"s_ForwardTOF_t");
   return p;
}

s_Slabs_t* make_s_Slabs(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Slabs_t) + rep * sizeof(s_Slab_t);
   s_Slabs_t* p = CALLOC(size,"s_Slabs_t");
   return p;
}

s_Left_t* make_s_Left()
{
   int size = sizeof(s_Left_t);
   s_Left_t* p = CALLOC(size,"s_Left_t");
   return p;
}

s_Right_t* make_s_Right()
{
   int size = sizeof(s_Right_t);
   s_Right_t* p = CALLOC(size,"s_Right_t");
   return p;
}

s_TofPoints_t* make_s_TofPoints(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_TofPoints_t) + rep * sizeof(s_TofPoint_t);
   s_TofPoints_t* p = CALLOC(size,"s_TofPoints_t");
   return p;
}

s_ForwardEMcal_t* make_s_ForwardEMcal()
{
   int size = sizeof(s_ForwardEMcal_t);
   s_ForwardEMcal_t* p = CALLOC(size,"s_ForwardEMcal_t");
   return p;
}

s_Rows_t* make_s_Rows(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Rows_t) + rep * sizeof(s_Row_t);
   s_Rows_t* p = CALLOC(size,"s_Rows_t");
   return p;
}

s_Columns_t* make_s_Columns(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_Columns_t) + rep * sizeof(s_Column_t);
   s_Columns_t* p = CALLOC(size,"s_Columns_t");
   return p;
}

s_ForwardShowers_t* make_s_ForwardShowers(int n)
{
   int rep = (n > 1) ? n-1 : 0;
   int size = sizeof(s_ForwardShowers_t) + rep * sizeof(s_ForwardShower_t);
   s_ForwardShowers_t* p = CALLOC(size,"s_ForwardShowers_t");
   return p;
}

char HDDM_s_DocumentString[] = 
"<HDDM class=\"s\" version=\"1.0\" xmlns=\"http://www.gluex.org/hddm\">\n"
"  <physicsEvent eventNo=\"int\" maxOccurs=\"unbounded\" runNo=\"int\">\n"
"    <reaction maxOccurs=\"unbounded\" minOccurs=\"0\" type=\"int\" weight=\"float\">\n"
"      <beam minOccurs=\"0\" type=\"Particle_t\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"      </beam>\n"
"      <target minOccurs=\"0\" type=\"Particle_t\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"      </target>\n"
"      <vertex maxOccurs=\"unbounded\">\n"
"        <product decayVertex=\"int\" maxOccurs=\"unbounded\" type=\"Particle_t\">\n"
"          <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"          <properties charge=\"int\" mass=\"float\" />\n"
"        </product>\n"
"        <origin t=\"float\" vx=\"float\" vy=\"float\" vz=\"float\" />\n"
"      </vertex>\n"
"    </reaction>\n"
"    <hitView version=\"1.0\">\n"
"      <centralDC minOccurs=\"0\">\n"
"        <cathodeCyl maxOccurs=\"unbounded\" minOccurs=\"0\" radius=\"float\">\n"
"          <band maxOccurs=\"unbounded\" phim=\"float\" z=\"float\" />\n"
"        </cathodeCyl>\n"
"        <ring maxOccurs=\"unbounded\" minOccurs=\"0\" radius=\"float\">\n"
"          <straw maxOccurs=\"unbounded\" phim=\"float\">\n"
"            <hit dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"            <cdcPoint dEdx=\"float\" dradius=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" r=\"float\" track=\"int\" z=\"float\" />\n"
"          </straw>\n"
"        </ring>\n"
"      </centralDC>\n"
"      <forwardDC minOccurs=\"0\">\n"
"        <chamber layer=\"int\" maxOccurs=\"unbounded\" module=\"int\">\n"
"          <cathodePlane maxOccurs=\"unbounded\" minOccurs=\"0\" tau=\"float\" z=\"float\">\n"
"            <strip maxOccurs=\"unbounded\" u=\"float\" />\n"
"          </cathodePlane>\n"
"          <anodePlane maxOccurs=\"unbounded\" minOccurs=\"0\" tau=\"float\" z=\"float\">\n"
"            <wire maxOccurs=\"unbounded\" u=\"float\">\n"
"              <hit dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"              <fdcPoint dEdx=\"float\" dradius=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"            </wire>\n"
"          </anodePlane>\n"
"        </chamber>\n"
"      </forwardDC>\n"
"      <startCntr minOccurs=\"0\">\n"
"        <paddle maxOccurs=\"unbounded\" minOccurs=\"0\" phim=\"float\">\n"
"          <hit dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"        </paddle>\n"
"        <startPoint dEdx=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\" />\n"
"      </startCntr>\n"
"      <barrelEMcal minOccurs=\"0\">\n"
"        <module maxOccurs=\"unbounded\" minOccurs=\"0\" phim=\"float\">\n"
"          <upstream minOccurs=\"0\">\n"
"            <shower E=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </upstream>\n"
"          <downstream minOccurs=\"0\">\n"
"            <shower E=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </downstream>\n"
"        </module>\n"
"        <barrelShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" t=\"float\" track=\"int\" z=\"float\" />\n"
"      </barrelEMcal>\n"
"      <Cerenkov minOccurs=\"0\">\n"
"        <section maxOccurs=\"unbounded\" phim=\"float\">\n"
"          <flash maxOccurs=\"unbounded\" pe=\"float\" t=\"float\" />\n"
"        </section>\n"
"      </Cerenkov>\n"
"      <forwardTOF minOccurs=\"0\">\n"
"        <slab maxOccurs=\"unbounded\" minOccurs=\"0\" y=\"float\">\n"
"          <left minOccurs=\"0\">\n"
"            <hit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </left>\n"
"          <right minOccurs=\"0\">\n"
"            <hit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </right>\n"
"        </slab>\n"
"        <tofPoint maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" />\n"
"      </forwardTOF>\n"
"      <forwardEMcal minOccurs=\"0\">\n"
"        <row maxOccurs=\"unbounded\" minOccurs=\"0\" y=\"float\">\n"
"          <column maxOccurs=\"unbounded\" minOccurs=\"0\" x=\"float\">\n"
"            <shower E=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </column>\n"
"        </row>\n"
"        <forwardShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" />\n"
"      </forwardEMcal>\n"
"    </hitView>\n"
"  </physicsEvent>\n"
"</HDDM>\n"
;


static s_HDDM_t* unpack_s_HDDM(XDR* xdrs, popNode* pop)
{
   s_HDDM_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_HDDM();
      {
         int p;
         void* (*ptr) = (void**) &this1->physicsEvents;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_PhysicsEvents_t* unpack_s_PhysicsEvents(XDR* xdrs, popNode* pop)
{
   s_PhysicsEvents_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_PhysicsEvents(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].reactions;
         xdr_int(xdrs,&this1->in[m].eventNo);
         xdr_int(xdrs,&this1->in[m].runNo);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Reactions_t* unpack_s_Reactions(XDR* xdrs, popNode* pop)
{
   s_Reactions_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Reactions(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].beam;
         xdr_int(xdrs,&this1->in[m].type);
         xdr_float(xdrs,&this1->in[m].weight);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Beam_t* unpack_s_Beam(XDR* xdrs, popNode* pop)
{
   s_Beam_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Beam();
      {
         int p;
         void* (*ptr) = (void**) &this1->momentum;
         xdr_int(xdrs,(int*)&this1->type);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Momentum_t* unpack_s_Momentum(XDR* xdrs, popNode* pop)
{
   s_Momentum_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Momentum();
      {
         xdr_float(xdrs,&this1->E);
         xdr_float(xdrs,&this1->px);
         xdr_float(xdrs,&this1->py);
         xdr_float(xdrs,&this1->pz);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Properties_t* unpack_s_Properties(XDR* xdrs, popNode* pop)
{
   s_Properties_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Properties();
      {
         xdr_int(xdrs,&this1->charge);
         xdr_float(xdrs,&this1->mass);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Target_t* unpack_s_Target(XDR* xdrs, popNode* pop)
{
   s_Target_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Target();
      {
         int p;
         void* (*ptr) = (void**) &this1->momentum;
         xdr_int(xdrs,(int*)&this1->type);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Vertices_t* unpack_s_Vertices(XDR* xdrs, popNode* pop)
{
   s_Vertices_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Vertices(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].products;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Products_t* unpack_s_Products(XDR* xdrs, popNode* pop)
{
   s_Products_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Products(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].momentum;
         xdr_int(xdrs,&this1->in[m].decayVertex);
         xdr_int(xdrs,(int*)&this1->in[m].type);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Origin_t* unpack_s_Origin(XDR* xdrs, popNode* pop)
{
   s_Origin_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Origin();
      {
         xdr_float(xdrs,&this1->t);
         xdr_float(xdrs,&this1->vx);
         xdr_float(xdrs,&this1->vy);
         xdr_float(xdrs,&this1->vz);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_HitView_t* unpack_s_HitView(XDR* xdrs, popNode* pop)
{
   s_HitView_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_HitView();
      {
         int p;
         void* (*ptr) = (void**) &this1->centralDC;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CentralDC_t* unpack_s_CentralDC(XDR* xdrs, popNode* pop)
{
   s_CentralDC_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_CentralDC();
      {
         int p;
         void* (*ptr) = (void**) &this1->cathodeCyls;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CathodeCyls_t* unpack_s_CathodeCyls(XDR* xdrs, popNode* pop)
{
   s_CathodeCyls_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CathodeCyls(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].bands;
         xdr_float(xdrs,&this1->in[m].radius);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Bands_t* unpack_s_Bands(XDR* xdrs, popNode* pop)
{
   s_Bands_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Bands(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].phim);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Rings_t* unpack_s_Rings(XDR* xdrs, popNode* pop)
{
   s_Rings_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Rings(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].straws;
         xdr_float(xdrs,&this1->in[m].radius);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Straws_t* unpack_s_Straws(XDR* xdrs, popNode* pop)
{
   s_Straws_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Straws(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].hits;
         xdr_float(xdrs,&this1->in[m].phim);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Hits_t* unpack_s_Hits(XDR* xdrs, popNode* pop)
{
   s_Hits_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Hits(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dE);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CdcPoints_t* unpack_s_CdcPoints(XDR* xdrs, popNode* pop)
{
   s_CdcPoints_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CdcPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dEdx);
         xdr_float(xdrs,&this1->in[m].dradius);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_float(xdrs,&this1->in[m].r);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardDC_t* unpack_s_ForwardDC(XDR* xdrs, popNode* pop)
{
   s_ForwardDC_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_ForwardDC();
      {
         int p;
         void* (*ptr) = (void**) &this1->chambers;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Chambers_t* unpack_s_Chambers(XDR* xdrs, popNode* pop)
{
   s_Chambers_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Chambers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].cathodePlanes;
         xdr_int(xdrs,&this1->in[m].layer);
         xdr_int(xdrs,&this1->in[m].module);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_CathodePlanes_t* unpack_s_CathodePlanes(XDR* xdrs, popNode* pop)
{
   s_CathodePlanes_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_CathodePlanes(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].strips;
         xdr_float(xdrs,&this1->in[m].tau);
         xdr_float(xdrs,&this1->in[m].z);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Strips_t* unpack_s_Strips(XDR* xdrs, popNode* pop)
{
   s_Strips_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Strips(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].u);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_AnodePlanes_t* unpack_s_AnodePlanes(XDR* xdrs, popNode* pop)
{
   s_AnodePlanes_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_AnodePlanes(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].wires;
         xdr_float(xdrs,&this1->in[m].tau);
         xdr_float(xdrs,&this1->in[m].z);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Wires_t* unpack_s_Wires(XDR* xdrs, popNode* pop)
{
   s_Wires_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Wires(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].hits;
         xdr_float(xdrs,&this1->in[m].u);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_FdcPoints_t* unpack_s_FdcPoints(XDR* xdrs, popNode* pop)
{
   s_FdcPoints_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_FdcPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dEdx);
         xdr_float(xdrs,&this1->in[m].dradius);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_StartCntr_t* unpack_s_StartCntr(XDR* xdrs, popNode* pop)
{
   s_StartCntr_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_StartCntr();
      {
         int p;
         void* (*ptr) = (void**) &this1->paddles;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Paddles_t* unpack_s_Paddles(XDR* xdrs, popNode* pop)
{
   s_Paddles_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Paddles(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].hits;
         xdr_float(xdrs,&this1->in[m].phim);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_StartPoints_t* unpack_s_StartPoints(XDR* xdrs, popNode* pop)
{
   s_StartPoints_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_StartPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].dEdx);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_float(xdrs,&this1->in[m].r);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_BarrelEMcal_t* unpack_s_BarrelEMcal(XDR* xdrs, popNode* pop)
{
   s_BarrelEMcal_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_BarrelEMcal();
      {
         int p;
         void* (*ptr) = (void**) &this1->modules;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Modules_t* unpack_s_Modules(XDR* xdrs, popNode* pop)
{
   s_Modules_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Modules(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].upstream;
         xdr_float(xdrs,&this1->in[m].phim);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Upstream_t* unpack_s_Upstream(XDR* xdrs, popNode* pop)
{
   s_Upstream_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Upstream();
      {
         int p;
         void* (*ptr) = (void**) &this1->showers;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Showers_t* unpack_s_Showers(XDR* xdrs, popNode* pop)
{
   s_Showers_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Showers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Downstream_t* unpack_s_Downstream(XDR* xdrs, popNode* pop)
{
   s_Downstream_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Downstream();
      {
         int p;
         void* (*ptr) = (void**) &this1->showers;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_BarrelShowers_t* unpack_s_BarrelShowers(XDR* xdrs, popNode* pop)
{
   s_BarrelShowers_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_BarrelShowers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].phi);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].z);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Cerenkov_t* unpack_s_Cerenkov(XDR* xdrs, popNode* pop)
{
   s_Cerenkov_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Cerenkov();
      {
         int p;
         void* (*ptr) = (void**) &this1->sections;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Sections_t* unpack_s_Sections(XDR* xdrs, popNode* pop)
{
   s_Sections_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Sections(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].flashes;
         xdr_float(xdrs,&this1->in[m].phim);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Flashes_t* unpack_s_Flashes(XDR* xdrs, popNode* pop)
{
   s_Flashes_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Flashes(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].pe);
         xdr_float(xdrs,&this1->in[m].t);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardTOF_t* unpack_s_ForwardTOF(XDR* xdrs, popNode* pop)
{
   s_ForwardTOF_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_ForwardTOF();
      {
         int p;
         void* (*ptr) = (void**) &this1->slabs;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Slabs_t* unpack_s_Slabs(XDR* xdrs, popNode* pop)
{
   s_Slabs_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Slabs(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].left;
         xdr_float(xdrs,&this1->in[m].y);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Left_t* unpack_s_Left(XDR* xdrs, popNode* pop)
{
   s_Left_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Left();
      {
         int p;
         void* (*ptr) = (void**) &this1->hits;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Right_t* unpack_s_Right(XDR* xdrs, popNode* pop)
{
   s_Right_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_Right();
      {
         int p;
         void* (*ptr) = (void**) &this1->hits;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_TofPoints_t* unpack_s_TofPoints(XDR* xdrs, popNode* pop)
{
   s_TofPoints_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_TofPoints(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardEMcal_t* unpack_s_ForwardEMcal(XDR* xdrs, popNode* pop)
{
   s_ForwardEMcal_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      this1 = make_s_ForwardEMcal();
      {
         int p;
         void* (*ptr) = (void**) &this1->rows;
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Rows_t* unpack_s_Rows(XDR* xdrs, popNode* pop)
{
   s_Rows_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Rows(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].columns;
         xdr_float(xdrs,&this1->in[m].y);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_Columns_t* unpack_s_Columns(XDR* xdrs, popNode* pop)
{
   s_Columns_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_Columns(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         int p;
         void* (*ptr) = (void**) &this1->in[m].showers;
         xdr_float(xdrs,&this1->in[m].x);
         for (p = 0; p < pop->popListLength; p++)
         {
            popNode* pnode = pop->popList[p];
            if (pnode)
            {
               int kid = pnode->inParent;
               ptr[kid] = pnode->unpacker(xdrs,pnode);
            }
            else
            {
               unsigned int skip;
               xdr_u_int(xdrs,&skip);
               xdr_setpos(xdrs,xdr_getpos(xdrs)+skip);
            }
         }
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

static s_ForwardShowers_t* unpack_s_ForwardShowers(XDR* xdrs, popNode* pop)
{
   s_ForwardShowers_t* this1 = 0;
   unsigned int size;
   if (! xdr_u_int(xdrs,&size))
   {
       return 0;
   }
   else if (size > 0)
   {
      int start = xdr_getpos(xdrs);
      int m;
      int mult;
      xdr_u_int(xdrs,&mult);
      this1 = make_s_ForwardShowers(mult);
      this1->mult = mult;
      for (m = 0; m < mult; m++ )
      {
         xdr_float(xdrs,&this1->in[m].E);
         xdr_float(xdrs,&this1->in[m].t);
         xdr_int(xdrs,&this1->in[m].track);
         xdr_float(xdrs,&this1->in[m].x);
         xdr_float(xdrs,&this1->in[m].y);
      }
      xdr_setpos(xdrs,start+size);
   }
   return this1;
}

s_HDDM_t* read_s_HDDM(s_iostream_t* fp)
{
   return unpack_s_HDDM(fp->xdrs,fp->popTop);
}

static int pack_s_HDDM(XDR* xdrs, s_HDDM_t* this1);
static int pack_s_PhysicsEvents(XDR* xdrs, s_PhysicsEvents_t* this1);
static int pack_s_Reactions(XDR* xdrs, s_Reactions_t* this1);
static int pack_s_Beam(XDR* xdrs, s_Beam_t* this1);
static int pack_s_Momentum(XDR* xdrs, s_Momentum_t* this1);
static int pack_s_Properties(XDR* xdrs, s_Properties_t* this1);
static int pack_s_Target(XDR* xdrs, s_Target_t* this1);
static int pack_s_Vertices(XDR* xdrs, s_Vertices_t* this1);
static int pack_s_Products(XDR* xdrs, s_Products_t* this1);
static int pack_s_Origin(XDR* xdrs, s_Origin_t* this1);
static int pack_s_HitView(XDR* xdrs, s_HitView_t* this1);
static int pack_s_CentralDC(XDR* xdrs, s_CentralDC_t* this1);
static int pack_s_CathodeCyls(XDR* xdrs, s_CathodeCyls_t* this1);
static int pack_s_Bands(XDR* xdrs, s_Bands_t* this1);
static int pack_s_Rings(XDR* xdrs, s_Rings_t* this1);
static int pack_s_Straws(XDR* xdrs, s_Straws_t* this1);
static int pack_s_Hits(XDR* xdrs, s_Hits_t* this1);
static int pack_s_CdcPoints(XDR* xdrs, s_CdcPoints_t* this1);
static int pack_s_ForwardDC(XDR* xdrs, s_ForwardDC_t* this1);
static int pack_s_Chambers(XDR* xdrs, s_Chambers_t* this1);
static int pack_s_CathodePlanes(XDR* xdrs, s_CathodePlanes_t* this1);
static int pack_s_Strips(XDR* xdrs, s_Strips_t* this1);
static int pack_s_AnodePlanes(XDR* xdrs, s_AnodePlanes_t* this1);
static int pack_s_Wires(XDR* xdrs, s_Wires_t* this1);
static int pack_s_FdcPoints(XDR* xdrs, s_FdcPoints_t* this1);
static int pack_s_StartCntr(XDR* xdrs, s_StartCntr_t* this1);
static int pack_s_Paddles(XDR* xdrs, s_Paddles_t* this1);
static int pack_s_StartPoints(XDR* xdrs, s_StartPoints_t* this1);
static int pack_s_BarrelEMcal(XDR* xdrs, s_BarrelEMcal_t* this1);
static int pack_s_Modules(XDR* xdrs, s_Modules_t* this1);
static int pack_s_Upstream(XDR* xdrs, s_Upstream_t* this1);
static int pack_s_Showers(XDR* xdrs, s_Showers_t* this1);
static int pack_s_Downstream(XDR* xdrs, s_Downstream_t* this1);
static int pack_s_BarrelShowers(XDR* xdrs, s_BarrelShowers_t* this1);
static int pack_s_Cerenkov(XDR* xdrs, s_Cerenkov_t* this1);
static int pack_s_Sections(XDR* xdrs, s_Sections_t* this1);
static int pack_s_Flashes(XDR* xdrs, s_Flashes_t* this1);
static int pack_s_ForwardTOF(XDR* xdrs, s_ForwardTOF_t* this1);
static int pack_s_Slabs(XDR* xdrs, s_Slabs_t* this1);
static int pack_s_Left(XDR* xdrs, s_Left_t* this1);
static int pack_s_Right(XDR* xdrs, s_Right_t* this1);
static int pack_s_TofPoints(XDR* xdrs, s_TofPoints_t* this1);
static int pack_s_ForwardEMcal(XDR* xdrs, s_ForwardEMcal_t* this1);
static int pack_s_Rows(XDR* xdrs, s_Rows_t* this1);
static int pack_s_Columns(XDR* xdrs, s_Columns_t* this1);
static int pack_s_ForwardShowers(XDR* xdrs, s_ForwardShowers_t* this1);

static int pack_s_HDDM(XDR* xdrs, s_HDDM_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->physicsEvents)
      {
         pack_s_PhysicsEvents(xdrs,this1->physicsEvents);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_PhysicsEvents(XDR* xdrs, s_PhysicsEvents_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].eventNo);
      xdr_int(xdrs,&this1->in[m].runNo);
      if (this1->in[m].reactions)
      {
         pack_s_Reactions(xdrs,this1->in[m].reactions);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].hitView)
      {
         pack_s_HitView(xdrs,this1->in[m].hitView);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Reactions(XDR* xdrs, s_Reactions_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].type);
      xdr_float(xdrs,&this1->in[m].weight);
      if (this1->in[m].beam)
      {
         pack_s_Beam(xdrs,this1->in[m].beam);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].target)
      {
         pack_s_Target(xdrs,this1->in[m].target);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].vertices)
      {
         pack_s_Vertices(xdrs,this1->in[m].vertices);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Beam(XDR* xdrs, s_Beam_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      xdr_int(xdrs,(int*)&this1->type);
      if (this1->momentum)
      {
         pack_s_Momentum(xdrs,this1->momentum);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->properties)
      {
         pack_s_Properties(xdrs,this1->properties);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Momentum(XDR* xdrs, s_Momentum_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      xdr_float(xdrs,&this1->E);
      xdr_float(xdrs,&this1->px);
      xdr_float(xdrs,&this1->py);
      xdr_float(xdrs,&this1->pz);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Properties(XDR* xdrs, s_Properties_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      xdr_int(xdrs,&this1->charge);
      xdr_float(xdrs,&this1->mass);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Target(XDR* xdrs, s_Target_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      xdr_int(xdrs,(int*)&this1->type);
      if (this1->momentum)
      {
         pack_s_Momentum(xdrs,this1->momentum);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->properties)
      {
         pack_s_Properties(xdrs,this1->properties);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Vertices(XDR* xdrs, s_Vertices_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      if (this1->in[m].products)
      {
         pack_s_Products(xdrs,this1->in[m].products);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].origin)
      {
         pack_s_Origin(xdrs,this1->in[m].origin);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Products(XDR* xdrs, s_Products_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].decayVertex);
      xdr_int(xdrs,(int*)&this1->in[m].type);
      if (this1->in[m].momentum)
      {
         pack_s_Momentum(xdrs,this1->in[m].momentum);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].properties)
      {
         pack_s_Properties(xdrs,this1->in[m].properties);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Origin(XDR* xdrs, s_Origin_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      xdr_float(xdrs,&this1->t);
      xdr_float(xdrs,&this1->vx);
      xdr_float(xdrs,&this1->vy);
      xdr_float(xdrs,&this1->vz);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_HitView(XDR* xdrs, s_HitView_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->centralDC)
      {
         pack_s_CentralDC(xdrs,this1->centralDC);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardDC)
      {
         pack_s_ForwardDC(xdrs,this1->forwardDC);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->startCntr)
      {
         pack_s_StartCntr(xdrs,this1->startCntr);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->barrelEMcal)
      {
         pack_s_BarrelEMcal(xdrs,this1->barrelEMcal);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->Cerenkov)
      {
         pack_s_Cerenkov(xdrs,this1->Cerenkov);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardTOF)
      {
         pack_s_ForwardTOF(xdrs,this1->forwardTOF);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardEMcal)
      {
         pack_s_ForwardEMcal(xdrs,this1->forwardEMcal);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CentralDC(XDR* xdrs, s_CentralDC_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->cathodeCyls)
      {
         pack_s_CathodeCyls(xdrs,this1->cathodeCyls);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->rings)
      {
         pack_s_Rings(xdrs,this1->rings);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CathodeCyls(XDR* xdrs, s_CathodeCyls_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].radius);
      if (this1->in[m].bands)
      {
         pack_s_Bands(xdrs,this1->in[m].bands);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Bands(XDR* xdrs, s_Bands_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].phim);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Rings(XDR* xdrs, s_Rings_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].radius);
      if (this1->in[m].straws)
      {
         pack_s_Straws(xdrs,this1->in[m].straws);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Straws(XDR* xdrs, s_Straws_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].phim);
      if (this1->in[m].hits)
      {
         pack_s_Hits(xdrs,this1->in[m].hits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].cdcPoints)
      {
         pack_s_CdcPoints(xdrs,this1->in[m].cdcPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Hits(XDR* xdrs, s_Hits_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dE);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CdcPoints(XDR* xdrs, s_CdcPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dEdx);
      xdr_float(xdrs,&this1->in[m].dradius);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_float(xdrs,&this1->in[m].r);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardDC(XDR* xdrs, s_ForwardDC_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->chambers)
      {
         pack_s_Chambers(xdrs,this1->chambers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Chambers(XDR* xdrs, s_Chambers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_int(xdrs,&this1->in[m].layer);
      xdr_int(xdrs,&this1->in[m].module);
      if (this1->in[m].cathodePlanes)
      {
         pack_s_CathodePlanes(xdrs,this1->in[m].cathodePlanes);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].anodePlanes)
      {
         pack_s_AnodePlanes(xdrs,this1->in[m].anodePlanes);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_CathodePlanes(XDR* xdrs, s_CathodePlanes_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].tau);
      xdr_float(xdrs,&this1->in[m].z);
      if (this1->in[m].strips)
      {
         pack_s_Strips(xdrs,this1->in[m].strips);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Strips(XDR* xdrs, s_Strips_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].u);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_AnodePlanes(XDR* xdrs, s_AnodePlanes_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].tau);
      xdr_float(xdrs,&this1->in[m].z);
      if (this1->in[m].wires)
      {
         pack_s_Wires(xdrs,this1->in[m].wires);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Wires(XDR* xdrs, s_Wires_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].u);
      if (this1->in[m].hits)
      {
         pack_s_Hits(xdrs,this1->in[m].hits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].fdcPoints)
      {
         pack_s_FdcPoints(xdrs,this1->in[m].fdcPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_FdcPoints(XDR* xdrs, s_FdcPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dEdx);
      xdr_float(xdrs,&this1->in[m].dradius);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_StartCntr(XDR* xdrs, s_StartCntr_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->paddles)
      {
         pack_s_Paddles(xdrs,this1->paddles);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->startPoints)
      {
         pack_s_StartPoints(xdrs,this1->startPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Paddles(XDR* xdrs, s_Paddles_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].phim);
      if (this1->in[m].hits)
      {
         pack_s_Hits(xdrs,this1->in[m].hits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_StartPoints(XDR* xdrs, s_StartPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].dEdx);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_float(xdrs,&this1->in[m].r);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_BarrelEMcal(XDR* xdrs, s_BarrelEMcal_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->modules)
      {
         pack_s_Modules(xdrs,this1->modules);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->barrelShowers)
      {
         pack_s_BarrelShowers(xdrs,this1->barrelShowers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Modules(XDR* xdrs, s_Modules_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].phim);
      if (this1->in[m].upstream)
      {
         pack_s_Upstream(xdrs,this1->in[m].upstream);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].downstream)
      {
         pack_s_Downstream(xdrs,this1->in[m].downstream);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Upstream(XDR* xdrs, s_Upstream_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->showers)
      {
         pack_s_Showers(xdrs,this1->showers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Showers(XDR* xdrs, s_Showers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Downstream(XDR* xdrs, s_Downstream_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->showers)
      {
         pack_s_Showers(xdrs,this1->showers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_BarrelShowers(XDR* xdrs, s_BarrelShowers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].phi);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].z);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Cerenkov(XDR* xdrs, s_Cerenkov_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->sections)
      {
         pack_s_Sections(xdrs,this1->sections);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Sections(XDR* xdrs, s_Sections_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].phim);
      if (this1->in[m].flashes)
      {
         pack_s_Flashes(xdrs,this1->in[m].flashes);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Flashes(XDR* xdrs, s_Flashes_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].pe);
      xdr_float(xdrs,&this1->in[m].t);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardTOF(XDR* xdrs, s_ForwardTOF_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->slabs)
      {
         pack_s_Slabs(xdrs,this1->slabs);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->tofPoints)
      {
         pack_s_TofPoints(xdrs,this1->tofPoints);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Slabs(XDR* xdrs, s_Slabs_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].y);
      if (this1->in[m].left)
      {
         pack_s_Left(xdrs,this1->in[m].left);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->in[m].right)
      {
         pack_s_Right(xdrs,this1->in[m].right);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Left(XDR* xdrs, s_Left_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->hits)
      {
         pack_s_Hits(xdrs,this1->hits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Right(XDR* xdrs, s_Right_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->hits)
      {
         pack_s_Hits(xdrs,this1->hits);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_TofPoints(XDR* xdrs, s_TofPoints_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardEMcal(XDR* xdrs, s_ForwardEMcal_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   {
      if (this1->rows)
      {
         pack_s_Rows(xdrs,this1->rows);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
      if (this1->forwardShowers)
      {
         pack_s_ForwardShowers(xdrs,this1->forwardShowers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Rows(XDR* xdrs, s_Rows_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].y);
      if (this1->in[m].columns)
      {
         pack_s_Columns(xdrs,this1->in[m].columns);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_Columns(XDR* xdrs, s_Columns_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].x);
      if (this1->in[m].showers)
      {
         pack_s_Showers(xdrs,this1->in[m].showers);
      }
      else
      {
         int zero=0;
         xdr_int(xdrs,&zero);
      }
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

static int pack_s_ForwardShowers(XDR* xdrs, s_ForwardShowers_t* this1)
{
   int m;
   unsigned int size=0;
   int base,start,end;
   base = xdr_getpos(xdrs);
   xdr_u_int(xdrs,&size);
   start = xdr_getpos(xdrs);

   xdr_u_int(xdrs,&this1->mult);
   for (m = 0; m < this1->mult; m++)
   {
      xdr_float(xdrs,&this1->in[m].E);
      xdr_float(xdrs,&this1->in[m].t);
      xdr_int(xdrs,&this1->in[m].track);
      xdr_float(xdrs,&this1->in[m].x);
      xdr_float(xdrs,&this1->in[m].y);
   }
   FREE(this1);
   end = xdr_getpos(xdrs);
   xdr_setpos(xdrs,base);
   size = end-start;
   xdr_u_int(xdrs,&size);
   xdr_setpos(xdrs,end);
   return size;
}

int flush_s_HDDM(s_HDDM_t* this1,s_iostream_t* fp)
{
   if (this1 == 0)
   {
      return 0;
   }
   else if (fp == 0)
   {
      XDR* xdrs = malloc(sizeof(XDR));
      int max_buffer_size = 1000000;
      char* dump = malloc(max_buffer_size);
      xdrmem_create(xdrs,dump,max_buffer_size,XDR_ENCODE);
      pack_s_HDDM(xdrs,this1);
      xdr_destroy(xdrs);
      free(xdrs);
      free(dump);
      return 0;
   }
   else if (fp->iomode == HDDM_STREAM_OUTPUT)
   {
      pack_s_HDDM(fp->xdrs,this1);
      return 0;
   }
}

static int getTag(char* d, char* tag)
{
   int level;
   char* token;
   char line[500];
   strncpy(line,d,500);
   line[499] = 0;
   level = index(line,'<')-line;
   if (level < 500 &&
      (token = strtok(line+level+1," >")))
   {
      strncpy(tag,token,500);
      return level/2;
   }
   return -1;
}

static char* getEndTag(char* d, char* tag)
{
   char line[500];
   char endTag[510];
   strncpy(line,d,500);
   line[499] = 0;
   if (strstr(strtok(line,"\n"),"/>") == 0)
   {
      sprintf(endTag,"</%s>",tag);
   }
   else
   {
      strcpy(endTag,"/>");
   }
   return strstr(d,endTag);
}

static void collide(char* tag)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"input template model for tag ");
      fprintf(stderr,"%s does not match c code.", tag);
      fprintf(stderr,"\nPlease recompile.\n");
      exit(9);
   }

static popNode* matches(char* b, char* c)
{
   char btag[500];
   char ctag[500];
   int blevel, clevel;
   int ptrSeqNo = 0;
   blevel = getTag(b,btag);
   while ((clevel = getTag(c,ctag)) == blevel)
   {
      if ((clevel == blevel) && (strcmp(ctag,btag) == 0))
      {
         popNode* this1 = malloc(sizeof(popNode));
         int len = index(c+1,'\n') - c;
         if (strncmp(c,b,len) != 0)
         {
            collide(btag);
         }
         if (strcmp(btag,"HDDM") == 0)
         {
            this1->unpacker = (void*) unpack_s_HDDM;
         }
         else if (strcmp(btag,"physicsEvent") == 0)
         {
            this1->unpacker = (void*) unpack_s_PhysicsEvents;
         }
         else if (strcmp(btag,"reaction") == 0)
         {
            this1->unpacker = (void*) unpack_s_Reactions;
         }
         else if (strcmp(btag,"beam") == 0)
         {
            this1->unpacker = (void*) unpack_s_Beam;
         }
         else if (strcmp(btag,"momentum") == 0)
         {
            this1->unpacker = (void*) unpack_s_Momentum;
         }
         else if (strcmp(btag,"properties") == 0)
         {
            this1->unpacker = (void*) unpack_s_Properties;
         }
         else if (strcmp(btag,"target") == 0)
         {
            this1->unpacker = (void*) unpack_s_Target;
         }
         else if (strcmp(btag,"vertex") == 0)
         {
            this1->unpacker = (void*) unpack_s_Vertices;
         }
         else if (strcmp(btag,"product") == 0)
         {
            this1->unpacker = (void*) unpack_s_Products;
         }
         else if (strcmp(btag,"origin") == 0)
         {
            this1->unpacker = (void*) unpack_s_Origin;
         }
         else if (strcmp(btag,"hitView") == 0)
         {
            this1->unpacker = (void*) unpack_s_HitView;
         }
         else if (strcmp(btag,"centralDC") == 0)
         {
            this1->unpacker = (void*) unpack_s_CentralDC;
         }
         else if (strcmp(btag,"cathodeCyl") == 0)
         {
            this1->unpacker = (void*) unpack_s_CathodeCyls;
         }
         else if (strcmp(btag,"band") == 0)
         {
            this1->unpacker = (void*) unpack_s_Bands;
         }
         else if (strcmp(btag,"ring") == 0)
         {
            this1->unpacker = (void*) unpack_s_Rings;
         }
         else if (strcmp(btag,"straw") == 0)
         {
            this1->unpacker = (void*) unpack_s_Straws;
         }
         else if (strcmp(btag,"hit") == 0)
         {
            this1->unpacker = (void*) unpack_s_Hits;
         }
         else if (strcmp(btag,"cdcPoint") == 0)
         {
            this1->unpacker = (void*) unpack_s_CdcPoints;
         }
         else if (strcmp(btag,"forwardDC") == 0)
         {
            this1->unpacker = (void*) unpack_s_ForwardDC;
         }
         else if (strcmp(btag,"chamber") == 0)
         {
            this1->unpacker = (void*) unpack_s_Chambers;
         }
         else if (strcmp(btag,"cathodePlane") == 0)
         {
            this1->unpacker = (void*) unpack_s_CathodePlanes;
         }
         else if (strcmp(btag,"strip") == 0)
         {
            this1->unpacker = (void*) unpack_s_Strips;
         }
         else if (strcmp(btag,"anodePlane") == 0)
         {
            this1->unpacker = (void*) unpack_s_AnodePlanes;
         }
         else if (strcmp(btag,"wire") == 0)
         {
            this1->unpacker = (void*) unpack_s_Wires;
         }
         else if (strcmp(btag,"fdcPoint") == 0)
         {
            this1->unpacker = (void*) unpack_s_FdcPoints;
         }
         else if (strcmp(btag,"startCntr") == 0)
         {
            this1->unpacker = (void*) unpack_s_StartCntr;
         }
         else if (strcmp(btag,"paddle") == 0)
         {
            this1->unpacker = (void*) unpack_s_Paddles;
         }
         else if (strcmp(btag,"startPoint") == 0)
         {
            this1->unpacker = (void*) unpack_s_StartPoints;
         }
         else if (strcmp(btag,"barrelEMcal") == 0)
         {
            this1->unpacker = (void*) unpack_s_BarrelEMcal;
         }
         else if (strcmp(btag,"module") == 0)
         {
            this1->unpacker = (void*) unpack_s_Modules;
         }
         else if (strcmp(btag,"upstream") == 0)
         {
            this1->unpacker = (void*) unpack_s_Upstream;
         }
         else if (strcmp(btag,"shower") == 0)
         {
            this1->unpacker = (void*) unpack_s_Showers;
         }
         else if (strcmp(btag,"downstream") == 0)
         {
            this1->unpacker = (void*) unpack_s_Downstream;
         }
         else if (strcmp(btag,"barrelShower") == 0)
         {
            this1->unpacker = (void*) unpack_s_BarrelShowers;
         }
         else if (strcmp(btag,"Cerenkov") == 0)
         {
            this1->unpacker = (void*) unpack_s_Cerenkov;
         }
         else if (strcmp(btag,"section") == 0)
         {
            this1->unpacker = (void*) unpack_s_Sections;
         }
         else if (strcmp(btag,"flash") == 0)
         {
            this1->unpacker = (void*) unpack_s_Flashes;
         }
         else if (strcmp(btag,"forwardTOF") == 0)
         {
            this1->unpacker = (void*) unpack_s_ForwardTOF;
         }
         else if (strcmp(btag,"slab") == 0)
         {
            this1->unpacker = (void*) unpack_s_Slabs;
         }
         else if (strcmp(btag,"left") == 0)
         {
            this1->unpacker = (void*) unpack_s_Left;
         }
         else if (strcmp(btag,"right") == 0)
         {
            this1->unpacker = (void*) unpack_s_Right;
         }
         else if (strcmp(btag,"tofPoint") == 0)
         {
            this1->unpacker = (void*) unpack_s_TofPoints;
         }
         else if (strcmp(btag,"forwardEMcal") == 0)
         {
            this1->unpacker = (void*) unpack_s_ForwardEMcal;
         }
         else if (strcmp(btag,"row") == 0)
         {
            this1->unpacker = (void*) unpack_s_Rows;
         }
         else if (strcmp(btag,"column") == 0)
         {
            this1->unpacker = (void*) unpack_s_Columns;
         }
         else if (strcmp(btag,"forwardShower") == 0)
         {
            this1->unpacker = (void*) unpack_s_ForwardShowers;
         }
         else
         {
            collide(btag);
         }
         this1->inParent = ptrSeqNo;
         this1->popListLength = 0;
         c = index(c+1,'\n');
         b = index(b+1,'\n');
         while (getTag(b,btag) > blevel)
         {
            this1->popList[this1->popListLength++] = matches(b,c);
            if (this1->popListLength > 99)
            {
               fprintf(stderr,"hddm error - posList overflow.\n");
               fprintf(stderr,"Increase MAX_POPLIST_LENGTH and recompile.\n");
               exit(9);
            }
            b = getEndTag(b,btag);
            b = index(b+1,'\n');
         }
         return this1;
      }
      else
      {
         c = getEndTag(c,ctag);
         c = index(c+1,'\n');
         ++ptrSeqNo;
      }
   }
   return 0;
}

s_iostream_t* open_s_HDDM(char* filename)
{
   s_iostream_t* fp = malloc(sizeof(s_iostream_t));
   char* p;
   char* head;
   if (filename)
   {
      fp->fd = fopen(filename,"r");
   }
   else
   {
      fp->fd = fdopen(0,"r");
   }
   if (fp->fd == 0)
   {
      free(fp);
      return 0;
   }
   fp->iomode = HDDM_STREAM_INPUT;
   head = malloc(1000000);
   *head = 0;
   for (p = head;
        strstr(head,"</HDDM>") == 0;
        p += strlen(p))
   {
      if (p-head < 999000)
      {
         fgets(p,1000,fp->fd);
      }
      else
      {
         break;
      }
   }
   fp->popTop = matches(head,HDDM_s_DocumentString);
   if (fp->popTop == 0)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"input template model ");
      fprintf(stderr,"does not match c code.");
      fprintf(stderr,"  Please recompile.\n");
      exit(9);
   }
   fp->filename = malloc(strlen(filename) + 1);
   strcpy(fp->filename,filename);
   fp->xdrs = malloc(sizeof(XDR));
   xdrstdio_create(fp->xdrs,fp->fd,XDR_DECODE);
   return fp;
}

s_iostream_t* init_s_HDDM(char* filename)
{
   int len;
   char* head;
   s_iostream_t* fp = malloc(sizeof(s_iostream_t));
   if (filename)
   {
      fp->fd = fopen(filename,"w");
   }
   else
   {
      fp->fd = fdopen(1,"w");
   }
   if (fp->fd == 0)
   {
      free(fp);
      return 0;
   }
   fp->iomode = HDDM_STREAM_OUTPUT;
   len = strlen(HDDM_s_DocumentString);
   head = malloc(len+1);
   strcpy(head,HDDM_s_DocumentString);
   if (fwrite(head,1,len,fp->fd) != len)
   {
      fprintf(stderr,"HDDM Error: ");
      fprintf(stderr,"error writing to ");
      fprintf(stderr,"output file %s\n",filename);
      exit(9);
   }
   fp->filename = malloc(strlen(filename) + 1);
   strcpy(fp->filename,filename);
   fp->popTop = 0;
   fp->xdrs = malloc(sizeof(XDR));
   xdrstdio_create(fp->xdrs,fp->fd,XDR_ENCODE);
   free(head);
   return fp;
}

void popaway(popNode* p)
{
   if (p)
   {
      int n;
      for (n = 0; n < p->popListLength; n++)
      {
         popaway(p->popList[n]);
      }
      free(p);
   }
}

void close_s_HDDM(s_iostream_t* fp)
{
   xdr_destroy(fp->xdrs);
   free(fp->xdrs);
   fclose(fp->fd);
   free(fp->filename);
   popaway(fp->popTop);
   free(fp);
}
